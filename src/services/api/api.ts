/* tslint:disable */
/* eslint-disable */
/**
 * API Document for Kiai Library
 * API Document for Kiai Library
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AdminOrdersPost200Response
 */
export interface AdminOrdersPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AdminOrdersPost200Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof AdminOrdersPost200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminOrdersPost200Response
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface AdminOrdersPost400Response
 */
export interface AdminOrdersPost400Response {
    /**
     * 
     * @type {string}
     * @memberof AdminOrdersPost400Response
     */
    'message'?: string;
    /**
     * 
     * @type {AdminOrdersPost400ResponseErrors}
     * @memberof AdminOrdersPost400Response
     */
    'errors'?: AdminOrdersPost400ResponseErrors;
}
/**
 * 
 * @export
 * @interface AdminOrdersPost400ResponseErrors
 */
export interface AdminOrdersPost400ResponseErrors {
    /**
     * 
     * @type {Array<string>}
     * @memberof AdminOrdersPost400ResponseErrors
     */
    'items'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AdminOrdersPost401Response
 */
export interface AdminOrdersPost401Response {
    /**
     * 
     * @type {string}
     * @memberof AdminOrdersPost401Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AdminOrdersPost500Response
 */
export interface AdminOrdersPost500Response {
    /**
     * 
     * @type {string}
     * @memberof AdminOrdersPost500Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AdminOrdersPostRequest
 */
export interface AdminOrdersPostRequest {
    /**
     * User\'s full name
     * @type {string}
     * @memberof AdminOrdersPostRequest
     */
    'full_name': string;
    /**
     * User\'s email address
     * @type {string}
     * @memberof AdminOrdersPostRequest
     */
    'email': string;
    /**
     * User\'s phone number (optional, will use user\'s profile phone if not provided)
     * @type {string}
     * @memberof AdminOrdersPostRequest
     */
    'phone_number'?: string;
    /**
     * ID of the province
     * @type {number}
     * @memberof AdminOrdersPostRequest
     */
    'province_id': number;
    /**
     * ID of the district
     * @type {number}
     * @memberof AdminOrdersPostRequest
     */
    'district_id': number;
    /**
     * ID of the ward
     * @type {number}
     * @memberof AdminOrdersPostRequest
     */
    'ward_id': number;
    /**
     * User\'s address
     * @type {string}
     * @memberof AdminOrdersPostRequest
     */
    'address': string;
    /**
     * List of items to checkout
     * @type {Array<AdminOrdersPostRequestItemsInner>}
     * @memberof AdminOrdersPostRequest
     */
    'items': Array<AdminOrdersPostRequestItemsInner>;
}
/**
 * 
 * @export
 * @interface AdminOrdersPostRequestItemsInner
 */
export interface AdminOrdersPostRequestItemsInner {
    /**
     * ID of the book
     * @type {number}
     * @memberof AdminOrdersPostRequestItemsInner
     */
    'book_id': number;
    /**
     * Quantity of the book
     * @type {number}
     * @memberof AdminOrdersPostRequestItemsInner
     */
    'quantity': number;
    /**
     * Due date for returning the book
     * @type {string}
     * @memberof AdminOrdersPostRequestItemsInner
     */
    'return_date_due': string;
}
/**
 * 
 * @export
 * @interface AdminUpdateReview200Response
 */
export interface AdminUpdateReview200Response {
    /**
     * response success
     * @type {string}
     * @memberof AdminUpdateReview200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Review}
     * @memberof AdminUpdateReview200Response
     */
    'data': Review;
}
/**
 * 
 * @export
 * @interface AdminUpdateUser200Response
 */
export interface AdminUpdateUser200Response {
    /**
     * response success
     * @type {string}
     * @memberof AdminUpdateUser200Response
     */
    'message'?: string;
    /**
     * 
     * @type {User}
     * @memberof AdminUpdateUser200Response
     */
    'data': User;
}
/**
 * 
 * @export
 * @interface Auth
 */
export interface Auth {
    /**
     * access token
     * @type {string}
     * @memberof Auth
     */
    'access_token': string;
    /**
     * type of token
     * @type {string}
     * @memberof Auth
     */
    'token_type': string;
    /**
     * expires
     * @type {number}
     * @memberof Auth
     */
    'expires_in': number;
    /**
     * 
     * @type {AuthProfile}
     * @memberof Auth
     */
    'profile': AuthProfile;
}
/**
 * 
 * @export
 * @interface AuthForgotPasswordRequest
 */
export interface AuthForgotPasswordRequest {
    /**
     * email
     * @type {string}
     * @memberof AuthForgotPasswordRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface AuthLoginRequest
 */
export interface AuthLoginRequest {
    /**
     * email
     * @type {string}
     * @memberof AuthLoginRequest
     */
    'email': string;
    /**
     * Admin Password
     * @type {string}
     * @memberof AuthLoginRequest
     */
    'password': string;
}
/**
 * admin profile
 * @export
 * @interface AuthProfile
 */
export interface AuthProfile {
    /**
     * admin full name
     * @type {string}
     * @memberof AuthProfile
     */
    'full_name'?: string;
    /**
     * admin email
     * @type {string}
     * @memberof AuthProfile
     */
    'email': string;
    /**
     * admin role
     * @type {number}
     * @memberof AuthProfile
     */
    'role'?: number;
}
/**
 * 
 * @export
 * @interface AuthResetPasswordRequest
 */
export interface AuthResetPasswordRequest {
    /**
     * email
     * @type {string}
     * @memberof AuthResetPasswordRequest
     */
    'email': string;
    /**
     * Password
     * @type {string}
     * @memberof AuthResetPasswordRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthSignupRequest
 */
export interface AuthSignupRequest {
    /**
     * Full name
     * @type {string}
     * @memberof AuthSignupRequest
     */
    'full_name': string;
    /**
     * Email
     * @type {string}
     * @memberof AuthSignupRequest
     */
    'email': string;
    /**
     * Password
     * @type {string}
     * @memberof AuthSignupRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Author
 */
export interface Author {
    /**
     * ID of the author
     * @type {number}
     * @memberof Author
     */
    'id'?: number;
    /**
     * Name of the author
     * @type {string}
     * @memberof Author
     */
    'name'?: string;
    /**
     * Slug of the author
     * @type {string}
     * @memberof Author
     */
    'slug'?: string;
    /**
     * Description of the author
     * @type {string}
     * @memberof Author
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Book
 */
export interface Book {
    /**
     * ID of the book
     * @type {number}
     * @memberof Book
     */
    'id'?: number;
    /**
     * Title of the book
     * @type {string}
     * @memberof Book
     */
    'title'?: string;
    /**
     * Slug of the book
     * @type {string}
     * @memberof Book
     */
    'slug'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Book
     */
    'author'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Book
     */
    'category'?: Array<string>;
    /**
     * Publisher of the book
     * @type {string}
     * @memberof Book
     */
    'publisher'?: string;
    /**
     * Publication year of the book
     * @type {number}
     * @memberof Book
     */
    'publication_year'?: number;
    /**
     * Short description of the book
     * @type {string}
     * @memberof Book
     */
    'short_description'?: string;
    /**
     * Description of the book
     * @type {string}
     * @memberof Book
     */
    'description'?: string;
    /**
     * Image URL of the book
     * @type {string}
     * @memberof Book
     */
    'image_url'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Book
     */
    'additional_images'?: Array<string>;
    /**
     * Number of order details associated with the book
     * @type {number}
     * @memberof Book
     */
    'order_details_count'?: number;
    /**
     * Number of favorites associated with the book
     * @type {number}
     * @memberof Book
     */
    'favorite_count'?: number;
    /**
     * Average star rating of the book
     * @type {number}
     * @memberof Book
     */
    'average_star'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Book
     */
    'star_distribution'?: Array<number>;
    /**
     * Number of reviews associated with the book
     * @type {number}
     * @memberof Book
     */
    'review_count'?: number;
    /**
     * Date and time when the book was deleted
     * @type {string}
     * @memberof Book
     */
    'deleted_at'?: string;
    /**
     * Availability status of the book
     * @type {string}
     * @memberof Book
     */
    'availability_status'?: string;
}
/**
 * 
 * @export
 * @interface Cart
 */
export interface Cart {
    /**
     * ID of the cart item
     * @type {number}
     * @memberof Cart
     */
    'id'?: number;
    /**
     * 
     * @type {CartUser}
     * @memberof Cart
     */
    'user'?: CartUser;
    /**
     * 
     * @type {CartBook}
     * @memberof Cart
     */
    'book'?: CartBook;
    /**
     * Quantity of books in cart
     * @type {number}
     * @memberof Cart
     */
    'quantity'?: number;
    /**
     * Due date for returning the book
     * @type {string}
     * @memberof Cart
     */
    'return_date_due'?: string;
}
/**
 * 
 * @export
 * @interface CartBook
 */
export interface CartBook {
    /**
     * ID of the book
     * @type {number}
     * @memberof CartBook
     */
    'id'?: number;
    /**
     * Slug of the book
     * @type {string}
     * @memberof CartBook
     */
    'slug'?: string;
    /**
     * Title of the book
     * @type {string}
     * @memberof CartBook
     */
    'title'?: string;
    /**
     * Author of the book
     * @type {string}
     * @memberof CartBook
     */
    'author'?: string;
    /**
     * Available stock quantity
     * @type {number}
     * @memberof CartBook
     */
    'stock_quantity'?: number;
    /**
     * Number of pages
     * @type {number}
     * @memberof CartBook
     */
    'page'?: number;
    /**
     * Short description of the book
     * @type {string}
     * @memberof CartBook
     */
    'short_description'?: string;
    /**
     * Full description of the book
     * @type {string}
     * @memberof CartBook
     */
    'description'?: string;
    /**
     * URL to the book cover image
     * @type {string}
     * @memberof CartBook
     */
    'image_url'?: string;
    /**
     * Number of users who favorited this book
     * @type {number}
     * @memberof CartBook
     */
    'favorite_count'?: number;
    /**
     * Average rating of the book
     * @type {number}
     * @memberof CartBook
     */
    'average_star'?: number;
}
/**
 * 
 * @export
 * @interface CartUser
 */
export interface CartUser {
    /**
     * ID of the user
     * @type {number}
     * @memberof CartUser
     */
    'id'?: number;
    /**
     * Full name of the user
     * @type {string}
     * @memberof CartUser
     */
    'full_name'?: string;
    /**
     * Email of the user
     * @type {string}
     * @memberof CartUser
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * ID of the category
     * @type {number}
     * @memberof Category
     */
    'id'?: number;
    /**
     * Name of the category
     * @type {string}
     * @memberof Category
     */
    'name'?: string;
    /**
     * Slug of the category
     * @type {string}
     * @memberof Category
     */
    'slug'?: string;
    /**
     * Description of the category
     * @type {string}
     * @memberof Category
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateAuthor200Response
 */
export interface CreateAuthor200Response {
    /**
     * response success
     * @type {string}
     * @memberof CreateAuthor200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Author}
     * @memberof CreateAuthor200Response
     */
    'data': Author;
}
/**
 * 
 * @export
 * @interface CreateBook200Response
 */
export interface CreateBook200Response {
    /**
     * response success
     * @type {string}
     * @memberof CreateBook200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Book}
     * @memberof CreateBook200Response
     */
    'data': Book;
}
/**
 * 
 * @export
 * @interface CreateBookReview201Response
 */
export interface CreateBookReview201Response {
    /**
     * Response message
     * @type {string}
     * @memberof CreateBookReview201Response
     */
    'message': string;
    /**
     * 
     * @type {Review}
     * @memberof CreateBookReview201Response
     */
    'data': Review;
}
/**
 * 
 * @export
 * @interface CreateBookReviewRequest
 */
export interface CreateBookReviewRequest {
    /**
     * ID of the book being reviewed
     * @type {number}
     * @memberof CreateBookReviewRequest
     */
    'book_id'?: number;
    /**
     * Rating from 1 to 5 stars
     * @type {number}
     * @memberof CreateBookReviewRequest
     */
    'star': number;
    /**
     * Review comment
     * @type {string}
     * @memberof CreateBookReviewRequest
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface CreateCategory200Response
 */
export interface CreateCategory200Response {
    /**
     * response success
     * @type {string}
     * @memberof CreateCategory200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Category}
     * @memberof CreateCategory200Response
     */
    'data': Category;
}
/**
 * 
 * @export
 * @interface CreateEmployee200Response
 */
export interface CreateEmployee200Response {
    /**
     * response success
     * @type {string}
     * @memberof CreateEmployee200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Employee}
     * @memberof CreateEmployee200Response
     */
    'data': Employee;
}
/**
 * 
 * @export
 * @interface CreatePublisher200Response
 */
export interface CreatePublisher200Response {
    /**
     * response success
     * @type {string}
     * @memberof CreatePublisher200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Publisher}
     * @memberof CreatePublisher200Response
     */
    'data': Publisher;
}
/**
 * 
 * @export
 * @interface DeleteAuthor200Response
 */
export interface DeleteAuthor200Response {
    /**
     * response success
     * @type {string}
     * @memberof DeleteAuthor200Response
     */
    'message'?: string;
    /**
     * 
     * @type {DeleteAuthor200ResponseData}
     * @memberof DeleteAuthor200Response
     */
    'data'?: DeleteAuthor200ResponseData;
}
/**
 * 
 * @export
 * @interface DeleteAuthor200ResponseData
 */
export interface DeleteAuthor200ResponseData {
    /**
     * response success
     * @type {string}
     * @memberof DeleteAuthor200ResponseData
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteBook200Response
 */
export interface DeleteBook200Response {
    /**
     * response success
     * @type {string}
     * @memberof DeleteBook200Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DeleteCategory200Response
 */
export interface DeleteCategory200Response {
    /**
     * response success
     * @type {string}
     * @memberof DeleteCategory200Response
     */
    'message'?: string;
    /**
     * 
     * @type {DeleteCategory200ResponseData}
     * @memberof DeleteCategory200Response
     */
    'data'?: DeleteCategory200ResponseData;
}
/**
 * 
 * @export
 * @interface DeleteCategory200ResponseData
 */
export interface DeleteCategory200ResponseData {
    /**
     * response success
     * @type {string}
     * @memberof DeleteCategory200ResponseData
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteCategory404Response
 */
export interface DeleteCategory404Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteCategory404Response
     */
    'message': string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof DeleteCategory404Response
     */
    'errors': { [key: string]: Array<string>; } | null;
}
/**
 * 
 * @export
 * @interface DeleteEmployee200Response
 */
export interface DeleteEmployee200Response {
    /**
     * response success
     * @type {string}
     * @memberof DeleteEmployee200Response
     */
    'message'?: string;
    /**
     * response success
     * @type {string}
     * @memberof DeleteEmployee200Response
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface DeletePublisher200Response
 */
export interface DeletePublisher200Response {
    /**
     * response success
     * @type {string}
     * @memberof DeletePublisher200Response
     */
    'message'?: string;
    /**
     * response success
     * @type {string}
     * @memberof DeletePublisher200Response
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface Employee
 */
export interface Employee {
    /**
     * ID of the employee
     * @type {number}
     * @memberof Employee
     */
    'id'?: number;
    /**
     * Full name of the employee
     * @type {string}
     * @memberof Employee
     */
    'full_name'?: string;
    /**
     * Email of the employee
     * @type {string}
     * @memberof Employee
     */
    'email'?: string;
    /**
     * Employee code of the employee
     * @type {string}
     * @memberof Employee
     */
    'employee_code'?: string;
}
/**
 * 
 * @export
 * @interface ForgotPassword200Response
 */
export interface ForgotPassword200Response {
    /**
     * 
     * @type {string}
     * @memberof ForgotPassword200Response
     */
    'message'?: string;
    /**
     * 
     * @type {object}
     * @memberof ForgotPassword200Response
     */
    'data'?: object | null;
}
/**
 * 
 * @export
 * @interface GetAuthors200Response
 */
export interface GetAuthors200Response {
    /**
     * response success
     * @type {string}
     * @memberof GetAuthors200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Author>}
     * @memberof GetAuthors200Response
     */
    'data': Array<Author>;
}
/**
 * 
 * @export
 * @interface GetBookById200Response
 */
export interface GetBookById200Response {
    /**
     * response success
     * @type {string}
     * @memberof GetBookById200Response
     */
    'message': string;
    /**
     * 
     * @type {Book}
     * @memberof GetBookById200Response
     */
    'data': Book;
}
/**
 * 
 * @export
 * @interface GetBookById404Response
 */
export interface GetBookById404Response {
    /**
     * Error message
     * @type {string}
     * @memberof GetBookById404Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GetBooks200Response
 */
export interface GetBooks200Response {
    /**
     * response success
     * @type {string}
     * @memberof GetBooks200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Book>}
     * @memberof GetBooks200Response
     */
    'data': Array<Book>;
}
/**
 * 
 * @export
 * @interface GetBooksByCategory200Response
 */
export interface GetBooksByCategory200Response {
    /**
     * 
     * @type {string}
     * @memberof GetBooksByCategory200Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetBooksByCategory200Response
     */
    'code'?: number;
    /**
     * 
     * @type {Array<GetBooksByCategory200ResponseDataInner>}
     * @memberof GetBooksByCategory200Response
     */
    'data'?: Array<GetBooksByCategory200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface GetBooksByCategory200ResponseDataInner
 */
export interface GetBooksByCategory200ResponseDataInner {
    /**
     * 
     * @type {number}
     * @memberof GetBooksByCategory200ResponseDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetBooksByCategory200ResponseDataInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBooksByCategory200ResponseDataInner
     */
    'slug'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetBooksByCategory200ResponseDataInner
     */
    'book_count'?: number;
}
/**
 * 
 * @export
 * @interface GetBorrowedBooksByMonth200Response
 */
export interface GetBorrowedBooksByMonth200Response {
    /**
     * 
     * @type {string}
     * @memberof GetBorrowedBooksByMonth200Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetBorrowedBooksByMonth200Response
     */
    'code'?: number;
    /**
     * 
     * @type {Array<GetBorrowedBooksByMonth200ResponseDataInner>}
     * @memberof GetBorrowedBooksByMonth200Response
     */
    'data'?: Array<GetBorrowedBooksByMonth200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface GetBorrowedBooksByMonth200ResponseDataInner
 */
export interface GetBorrowedBooksByMonth200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetBorrowedBooksByMonth200ResponseDataInner
     */
    'month_year'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetBorrowedBooksByMonth200ResponseDataInner
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface GetCategories200Response
 */
export interface GetCategories200Response {
    /**
     * response success
     * @type {string}
     * @memberof GetCategories200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Category>}
     * @memberof GetCategories200Response
     */
    'data': Array<Category>;
}
/**
 * 
 * @export
 * @interface GetDistricts200Response
 */
export interface GetDistricts200Response {
    /**
     * 
     * @type {number}
     * @memberof GetDistricts200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetDistricts200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<GetDistricts200ResponseDataInner>}
     * @memberof GetDistricts200Response
     */
    'data'?: Array<GetDistricts200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface GetDistricts200ResponseDataInner
 */
export interface GetDistricts200ResponseDataInner {
    /**
     * 
     * @type {number}
     * @memberof GetDistricts200ResponseDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetDistricts200ResponseDataInner
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetDistricts200ResponseDataInner
     */
    'province_id'?: number;
}
/**
 * 
 * @export
 * @interface GetDistricts400Response
 */
export interface GetDistricts400Response {
    /**
     * 
     * @type {number}
     * @memberof GetDistricts400Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetDistricts400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetEmployees200Response
 */
export interface GetEmployees200Response {
    /**
     * response success
     * @type {string}
     * @memberof GetEmployees200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Employee>}
     * @memberof GetEmployees200Response
     */
    'data': Array<Employee>;
}
/**
 * 
 * @export
 * @interface GetMostFavoriteBooks200Response
 */
export interface GetMostFavoriteBooks200Response {
    /**
     * 
     * @type {string}
     * @memberof GetMostFavoriteBooks200Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetMostFavoriteBooks200Response
     */
    'code'?: number;
    /**
     * 
     * @type {Array<GetMostFavoriteBooks200ResponseDataInner>}
     * @memberof GetMostFavoriteBooks200Response
     */
    'data'?: Array<GetMostFavoriteBooks200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface GetMostFavoriteBooks200ResponseDataInner
 */
export interface GetMostFavoriteBooks200ResponseDataInner {
    /**
     * 
     * @type {number}
     * @memberof GetMostFavoriteBooks200ResponseDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetMostFavoriteBooks200ResponseDataInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMostFavoriteBooks200ResponseDataInner
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMostFavoriteBooks200ResponseDataInner
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMostFavoriteBooks200ResponseDataInner
     */
    'image_url'?: string;
    /**
     * 
     * @type {GetMostFavoriteBooks200ResponseDataInnerPublisher}
     * @memberof GetMostFavoriteBooks200ResponseDataInner
     */
    'publisher'?: GetMostFavoriteBooks200ResponseDataInnerPublisher;
    /**
     * 
     * @type {Array<GetMostFavoriteBooks200ResponseDataInnerCategoriesInner>}
     * @memberof GetMostFavoriteBooks200ResponseDataInner
     */
    'categories'?: Array<GetMostFavoriteBooks200ResponseDataInnerCategoriesInner>;
    /**
     * 
     * @type {number}
     * @memberof GetMostFavoriteBooks200ResponseDataInner
     */
    'favorite_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMostFavoriteBooks200ResponseDataInner
     */
    'reviews_avg_star'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMostFavoriteBooks200ResponseDataInner
     */
    'reviews_count'?: number;
}
/**
 * 
 * @export
 * @interface GetMostFavoriteBooks200ResponseDataInnerCategoriesInner
 */
export interface GetMostFavoriteBooks200ResponseDataInnerCategoriesInner {
    /**
     * 
     * @type {number}
     * @memberof GetMostFavoriteBooks200ResponseDataInnerCategoriesInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetMostFavoriteBooks200ResponseDataInnerCategoriesInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GetMostFavoriteBooks200ResponseDataInnerPublisher
 */
export interface GetMostFavoriteBooks200ResponseDataInnerPublisher {
    /**
     * 
     * @type {number}
     * @memberof GetMostFavoriteBooks200ResponseDataInnerPublisher
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetMostFavoriteBooks200ResponseDataInnerPublisher
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GetOrderByUser200Response
 */
export interface GetOrderByUser200Response {
    /**
     * 
     * @type {string}
     * @memberof GetOrderByUser200Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetOrderByUser200Response
     */
    'code'?: number;
    /**
     * 
     * @type {Array<Order>}
     * @memberof GetOrderByUser200Response
     */
    'data'?: Array<Order>;
    /**
     * 
     * @type {GetOrderByUser200ResponsePagination}
     * @memberof GetOrderByUser200Response
     */
    'pagination'?: GetOrderByUser200ResponsePagination;
}
/**
 * 
 * @export
 * @interface GetOrderByUser200ResponsePagination
 */
export interface GetOrderByUser200ResponsePagination {
    /**
     * 
     * @type {number}
     * @memberof GetOrderByUser200ResponsePagination
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderByUser200ResponsePagination
     */
    'current_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderByUser200ResponsePagination
     */
    'total_pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderByUser200ResponsePagination
     */
    'per_page'?: number;
}
/**
 * 
 * @export
 * @interface GetOrders200Response
 */
export interface GetOrders200Response {
    /**
     * response success
     * @type {string}
     * @memberof GetOrders200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Order>}
     * @memberof GetOrders200Response
     */
    'data': Array<Order>;
}
/**
 * 
 * @export
 * @interface GetProvinces200Response
 */
export interface GetProvinces200Response {
    /**
     * 
     * @type {number}
     * @memberof GetProvinces200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetProvinces200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<GetProvinces200ResponseDataInner>}
     * @memberof GetProvinces200Response
     */
    'data'?: Array<GetProvinces200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface GetProvinces200ResponseDataInner
 */
export interface GetProvinces200ResponseDataInner {
    /**
     * 
     * @type {number}
     * @memberof GetProvinces200ResponseDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetProvinces200ResponseDataInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GetProvinces500Response
 */
export interface GetProvinces500Response {
    /**
     * 
     * @type {number}
     * @memberof GetProvinces500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetProvinces500Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetPublishers200Response
 */
export interface GetPublishers200Response {
    /**
     * response success
     * @type {string}
     * @memberof GetPublishers200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Publisher>}
     * @memberof GetPublishers200Response
     */
    'data': Array<Publisher>;
}
/**
 * 
 * @export
 * @interface GetRelatedBooks200Response
 */
export interface GetRelatedBooks200Response {
    /**
     * response success
     * @type {string}
     * @memberof GetRelatedBooks200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<Book>}
     * @memberof GetRelatedBooks200Response
     */
    'data': Array<Book>;
}
/**
 * 
 * @export
 * @interface GetRelatedBooks404Response
 */
export interface GetRelatedBooks404Response {
    /**
     * 
     * @type {string}
     * @memberof GetRelatedBooks404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface GetReviews200Response
 */
export interface GetReviews200Response {
    /**
     * response success
     * @type {string}
     * @memberof GetReviews200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Review>}
     * @memberof GetReviews200Response
     */
    'data': Array<Review>;
}
/**
 * 
 * @export
 * @interface GetTopBorrowedBooks200Response
 */
export interface GetTopBorrowedBooks200Response {
    /**
     * 
     * @type {string}
     * @memberof GetTopBorrowedBooks200Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetTopBorrowedBooks200Response
     */
    'code'?: number;
    /**
     * 
     * @type {Array<GetTopBorrowedBooks200ResponseDataInner>}
     * @memberof GetTopBorrowedBooks200Response
     */
    'data'?: Array<GetTopBorrowedBooks200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface GetTopBorrowedBooks200ResponseDataInner
 */
export interface GetTopBorrowedBooks200ResponseDataInner {
    /**
     * 
     * @type {number}
     * @memberof GetTopBorrowedBooks200ResponseDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetTopBorrowedBooks200ResponseDataInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTopBorrowedBooks200ResponseDataInner
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTopBorrowedBooks200ResponseDataInner
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTopBorrowedBooks200ResponseDataInner
     */
    'image_url'?: string;
    /**
     * 
     * @type {GetTopBorrowedBooks200ResponseDataInnerPublisher}
     * @memberof GetTopBorrowedBooks200ResponseDataInner
     */
    'publisher'?: GetTopBorrowedBooks200ResponseDataInnerPublisher;
    /**
     * 
     * @type {Array<GetTopBorrowedBooks200ResponseDataInnerCategoriesInner>}
     * @memberof GetTopBorrowedBooks200ResponseDataInner
     */
    'categories'?: Array<GetTopBorrowedBooks200ResponseDataInnerCategoriesInner>;
    /**
     * 
     * @type {number}
     * @memberof GetTopBorrowedBooks200ResponseDataInner
     */
    'order_details_count'?: number;
}
/**
 * 
 * @export
 * @interface GetTopBorrowedBooks200ResponseDataInnerCategoriesInner
 */
export interface GetTopBorrowedBooks200ResponseDataInnerCategoriesInner {
    /**
     * 
     * @type {number}
     * @memberof GetTopBorrowedBooks200ResponseDataInnerCategoriesInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetTopBorrowedBooks200ResponseDataInnerCategoriesInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GetTopBorrowedBooks200ResponseDataInnerPublisher
 */
export interface GetTopBorrowedBooks200ResponseDataInnerPublisher {
    /**
     * 
     * @type {number}
     * @memberof GetTopBorrowedBooks200ResponseDataInnerPublisher
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetTopBorrowedBooks200ResponseDataInnerPublisher
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GetTopBorrowers200Response
 */
export interface GetTopBorrowers200Response {
    /**
     * 
     * @type {string}
     * @memberof GetTopBorrowers200Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetTopBorrowers200Response
     */
    'code'?: number;
    /**
     * 
     * @type {Array<GetTopBorrowers200ResponseDataInner>}
     * @memberof GetTopBorrowers200Response
     */
    'data'?: Array<GetTopBorrowers200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface GetTopBorrowers200ResponseDataInner
 */
export interface GetTopBorrowers200ResponseDataInner {
    /**
     * 
     * @type {number}
     * @memberof GetTopBorrowers200ResponseDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetTopBorrowers200ResponseDataInner
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTopBorrowers200ResponseDataInner
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetTopBorrowers200ResponseDataInner
     */
    'orders_count'?: number;
}
/**
 * 
 * @export
 * @interface GetUsers200Response
 */
export interface GetUsers200Response {
    /**
     * response success
     * @type {string}
     * @memberof GetUsers200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof GetUsers200Response
     */
    'data': Array<User>;
}
/**
 * 
 * @export
 * @interface GetWards200Response
 */
export interface GetWards200Response {
    /**
     * 
     * @type {number}
     * @memberof GetWards200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetWards200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<GetWards200ResponseDataInner>}
     * @memberof GetWards200Response
     */
    'data'?: Array<GetWards200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface GetWards200ResponseDataInner
 */
export interface GetWards200ResponseDataInner {
    /**
     * 
     * @type {number}
     * @memberof GetWards200ResponseDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetWards200ResponseDataInner
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetWards200ResponseDataInner
     */
    'district_id'?: number;
}
/**
 * 
 * @export
 * @interface GetWards400Response
 */
export interface GetWards400Response {
    /**
     * 
     * @type {number}
     * @memberof GetWards400Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetWards400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ImportEmployees200Response
 */
export interface ImportEmployees200Response {
    /**
     * response success
     * @type {string}
     * @memberof ImportEmployees200Response
     */
    'message'?: string;
    /**
     * 
     * @type {ImportEmployees200ResponseData}
     * @memberof ImportEmployees200Response
     */
    'data': ImportEmployees200ResponseData;
}
/**
 * 
 * @export
 * @interface ImportEmployees200ResponseData
 */
export interface ImportEmployees200ResponseData {
    /**
     * response success
     * @type {string}
     * @memberof ImportEmployees200ResponseData
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Employee>}
     * @memberof ImportEmployees200ResponseData
     */
    'employees'?: Array<Employee>;
}
/**
 * 
 * @export
 * @interface Login200Response
 */
export interface Login200Response {
    /**
     * response success
     * @type {string}
     * @memberof Login200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Auth}
     * @memberof Login200Response
     */
    'data': Auth;
}
/**
 * 
 * @export
 * @interface Login422Response
 */
export interface Login422Response {
    /**
     * Internal Server Error Code
     * @type {number}
     * @memberof Login422Response
     */
    'status_code'?: number;
    /**
     * Internal Server Error message
     * @type {string}
     * @memberof Login422Response
     */
    'message': string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof Login422Response
     */
    'errors': { [key: string]: Array<string>; } | null;
}
/**
 * 
 * @export
 * @interface Login500Response
 */
export interface Login500Response {
    /**
     * Internal Server Error message
     * @type {string}
     * @memberof Login500Response
     */
    'message': string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof Login500Response
     */
    'errors': { [key: string]: Array<string>; } | null;
}
/**
 * 
 * @export
 * @interface LoginGoogle200Response
 */
export interface LoginGoogle200Response {
    /**
     * JWT token for authentication
     * @type {string}
     * @memberof LoginGoogle200Response
     */
    'access_token'?: string;
    /**
     * 
     * @type {LoginGoogle200ResponseUser}
     * @memberof LoginGoogle200Response
     */
    'user'?: LoginGoogle200ResponseUser;
}
/**
 * 
 * @export
 * @interface LoginGoogle200ResponseUser
 */
export interface LoginGoogle200ResponseUser {
    /**
     * 
     * @type {number}
     * @memberof LoginGoogle200ResponseUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoginGoogle200ResponseUser
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginGoogle200ResponseUser
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoginGoogle200ResponseUser
     */
    'role'?: number;
    /**
     * 
     * @type {number}
     * @memberof LoginGoogle200ResponseUser
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoginGoogle200ResponseUser
     */
    'google_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginGoogle200ResponseUser
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginGoogle200ResponseUser
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface LoginGoogle400Response
 */
export interface LoginGoogle400Response {
    /**
     * 
     * @type {string}
     * @memberof LoginGoogle400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface LoginGoogle401Response
 */
export interface LoginGoogle401Response {
    /**
     * 
     * @type {string}
     * @memberof LoginGoogle401Response
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginGoogle401Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface LoginGoogle403Response
 */
export interface LoginGoogle403Response {
    /**
     * 
     * @type {string}
     * @memberof LoginGoogle403Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface LoginGoogle422Response
 */
export interface LoginGoogle422Response {
    /**
     * 
     * @type {string}
     * @memberof LoginGoogle422Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface LoginGoogle500Response
 */
export interface LoginGoogle500Response {
    /**
     * 
     * @type {string}
     * @memberof LoginGoogle500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface LoginGoogleRequest
 */
export interface LoginGoogleRequest {
    /**
     * Google OAuth token received from Google authentication
     * @type {string}
     * @memberof LoginGoogleRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface Logout200Response
 */
export interface Logout200Response {
    /**
     * 
     * @type {string}
     * @memberof Logout200Response
     */
    'msg'?: string;
    /**
     * 
     * @type {object}
     * @memberof Logout200Response
     */
    'data'?: object | null;
}
/**
 * 
 * @export
 * @interface Logout401Response
 */
export interface Logout401Response {
    /**
     * 
     * @type {string}
     * @memberof Logout401Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * ID of the publisher
     * @type {number}
     * @memberof Order
     */
    'id'?: number;
    /**
     * Status of the publisher (0 Pending 1 Approved 2 Rejected)
     * @type {string}
     * @memberof Order
     */
    'status'?: string;
    /**
     * Created at date of the publisher
     * @type {string}
     * @memberof Order
     */
    'created_at'?: string;
    /**
     * Full name of user
     * @type {string}
     * @memberof Order
     */
    'full_name'?: string;
    /**
     * Employee code of user
     * @type {string}
     * @memberof Order
     */
    'employee_code'?: string;
    /**
     * 
     * @type {Array<OrderDetail>}
     * @memberof Order
     */
    'details'?: Array<OrderDetail>;
}
/**
 * 
 * @export
 * @interface OrderDetail
 */
export interface OrderDetail {
    /**
     * ID of the order detail
     * @type {number}
     * @memberof OrderDetail
     */
    'id'?: number;
    /**
     * Title of the book
     * @type {string}
     * @memberof OrderDetail
     */
    'title'?: string;
    /**
     * Image URL of the book
     * @type {string}
     * @memberof OrderDetail
     */
    'image_url'?: string;
    /**
     * Due date of the book
     * @type {string}
     * @memberof OrderDetail
     */
    'return_date_due'?: string;
    /**
     * Real return date of the book
     * @type {string}
     * @memberof OrderDetail
     */
    'return_date_real'?: string;
    /**
     * Status of the book (0 Pending 1 Approved 2 Rejected)
     * @type {string}
     * @memberof OrderDetail
     */
    'status'?: string;
    /**
     * Quantity of the book
     * @type {number}
     * @memberof OrderDetail
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface PostAuthorRequest
 */
export interface PostAuthorRequest {
    /**
     * Name of the author
     * @type {string}
     * @memberof PostAuthorRequest
     */
    'name'?: string;
    /**
     * Description of the author
     * @type {string}
     * @memberof PostAuthorRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface PostCategoryRequest
 */
export interface PostCategoryRequest {
    /**
     * Name of the category
     * @type {string}
     * @memberof PostCategoryRequest
     */
    'name'?: string;
    /**
     * Description of the category
     * @type {string}
     * @memberof PostCategoryRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface PostEmployeeRequest
 */
export interface PostEmployeeRequest {
    /**
     * Employee code of the employee
     * @type {string}
     * @memberof PostEmployeeRequest
     */
    'employee_code'?: string;
    /**
     * Full name of the employee
     * @type {string}
     * @memberof PostEmployeeRequest
     */
    'full_name'?: string;
    /**
     * Email of the employee
     * @type {string}
     * @memberof PostEmployeeRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface PostPublisherRequest
 */
export interface PostPublisherRequest {
    /**
     * Name of the publisher
     * @type {string}
     * @memberof PostPublisherRequest
     */
    'name'?: string;
    /**
     * Description of the publisher
     * @type {string}
     * @memberof PostPublisherRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * User ID
     * @type {number}
     * @memberof Profile
     */
    'id': number;
    /**
     * User email
     * @type {string}
     * @memberof Profile
     */
    'email': string;
    /**
     * Full name of the user
     * @type {string}
     * @memberof Profile
     */
    'full_name': string;
    /**
     * Phone number of the user
     * @type {string}
     * @memberof Profile
     */
    'phone_number': string;
    /**
     * Gender (0 for male, 1 for female)
     * @type {number}
     * @memberof Profile
     */
    'gender': number;
    /**
     * Birth date of the user
     * @type {string}
     * @memberof Profile
     */
    'birth_date': string;
    /**
     * Employee ID
     * @type {number}
     * @memberof Profile
     */
    'employee_id': number;
    /**
     * Province ID
     * @type {number}
     * @memberof Profile
     */
    'province_id': number;
    /**
     * District ID
     * @type {number}
     * @memberof Profile
     */
    'district_id': number;
    /**
     * Ward ID
     * @type {number}
     * @memberof Profile
     */
    'ward_id': number;
    /**
     * Address of the user
     * @type {string}
     * @memberof Profile
     */
    'address': string;
    /**
     * Google ID of the user
     * @type {string}
     * @memberof Profile
     */
    'google_id': string;
    /**
     * Role of the user (e.g., 0 for admin)
     * @type {number}
     * @memberof Profile
     */
    'role': number;
    /**
     * Status of the user (e.g., 1 for active)
     * @type {number}
     * @memberof Profile
     */
    'status': number;
    /**
     * Timestamp when the user was created
     * @type {string}
     * @memberof Profile
     */
    'created_at': string;
    /**
     * Timestamp when the user was last updated
     * @type {string}
     * @memberof Profile
     */
    'updated_at': string;
    /**
     * Timestamp when the user was deleted (nullable)
     * @type {string}
     * @memberof Profile
     */
    'deleted_at'?: string | null;
}
/**
 * 
 * @export
 * @interface Profile200Response
 */
export interface Profile200Response {
    /**
     * 
     * @type {string}
     * @memberof Profile200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Profile}
     * @memberof Profile200Response
     */
    'data'?: Profile;
}
/**
 * 
 * @export
 * @interface Publisher
 */
export interface Publisher {
    /**
     * ID of the publisher
     * @type {number}
     * @memberof Publisher
     */
    'id'?: number;
    /**
     * Name of the publisher
     * @type {string}
     * @memberof Publisher
     */
    'name'?: string;
    /**
     * Description of the publisher
     * @type {string}
     * @memberof Publisher
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface PutAuthorRequest
 */
export interface PutAuthorRequest {
    /**
     * Name of the author
     * @type {string}
     * @memberof PutAuthorRequest
     */
    'name'?: string;
    /**
     * Description of the author
     * @type {string}
     * @memberof PutAuthorRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface PutCategoryRequest
 */
export interface PutCategoryRequest {
    /**
     * Name of the category
     * @type {string}
     * @memberof PutCategoryRequest
     */
    'name'?: string;
    /**
     * Description of the category
     * @type {string}
     * @memberof PutCategoryRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface PutEmployeeRequest
 */
export interface PutEmployeeRequest {
    /**
     * Employee code of the employee
     * @type {string}
     * @memberof PutEmployeeRequest
     */
    'employee_code'?: string;
    /**
     * Full name of the employee
     * @type {string}
     * @memberof PutEmployeeRequest
     */
    'full_name'?: string;
    /**
     * Email of the employee
     * @type {string}
     * @memberof PutEmployeeRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface PutPublisherRequest
 */
export interface PutPublisherRequest {
    /**
     * Name of the publisher
     * @type {string}
     * @memberof PutPublisherRequest
     */
    'name'?: string;
    /**
     * Description of the publisher
     * @type {string}
     * @memberof PutPublisherRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface PutReviewRequest
 */
export interface PutReviewRequest {
    /**
     * Status of review (0 Pending 1 Approved 2 Rejected)
     * @type {string}
     * @memberof PutReviewRequest
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface PutUserRequest
 */
export interface PutUserRequest {
    /**
     * Status of user (0 Inactive 1 Active)
     * @type {string}
     * @memberof PutUserRequest
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ResetPassword200Response
 */
export interface ResetPassword200Response {
    /**
     * response success
     * @type {string}
     * @memberof ResetPassword200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RestoreBook200Response
 */
export interface RestoreBook200Response {
    /**
     * response success
     * @type {string}
     * @memberof RestoreBook200Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface Review
 */
export interface Review {
    /**
     * ID of the review
     * @type {number}
     * @memberof Review
     */
    'id'?: number;
    /**
     * ID of the book
     * @type {number}
     * @memberof Review
     */
    'book_id'?: number;
    /**
     * Comment of the review
     * @type {string}
     * @memberof Review
     */
    'comment'?: string;
    /**
     * Status of the review (0 Pending 1 Approved 2 Rejected)
     * @type {string}
     * @memberof Review
     */
    'status'?: string;
    /**
     * Star rating of the review (1 to 5)
     * @type {number}
     * @memberof Review
     */
    'star'?: number;
    /**
     * 
     * @type {User}
     * @memberof Review
     */
    'user'?: User;
    /**
     * 
     * @type {Book}
     * @memberof Review
     */
    'book'?: Book;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface UpdateOrder200Response
 */
export interface UpdateOrder200Response {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrder200Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateOrder200Response
     */
    'code'?: number;
    /**
     * 
     * @type {Order}
     * @memberof UpdateOrder200Response
     */
    'data'?: Order;
}
/**
 * 
 * @export
 * @interface UpdateOrderRequest
 */
export interface UpdateOrderRequest {
    /**
     * List of order detail items to update
     * @type {Array<UpdateOrderRequestDetailsInner>}
     * @memberof UpdateOrderRequest
     */
    'details': Array<UpdateOrderRequestDetailsInner>;
}
/**
 * 
 * @export
 * @interface UpdateOrderRequestDetailsInner
 */
export interface UpdateOrderRequestDetailsInner {
    /**
     * ID of the order detail
     * @type {number}
     * @memberof UpdateOrderRequestDetailsInner
     */
    'id': number;
    /**
     * Status of the order detail (0 Borrowing, 1 Returned, 2 Overdue, 3 Lost)
     * @type {string}
     * @memberof UpdateOrderRequestDetailsInner
     */
    'status': string;
    /**
     * Real return date of the book (required when status is 1 - Returned)
     * @type {string}
     * @memberof UpdateOrderRequestDetailsInner
     */
    'return_date_real'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateUserPassword200Response
 */
export interface UpdateUserPassword200Response {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPassword200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserPassword422Response
 */
export interface UpdateUserPassword422Response {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPassword422Response
     */
    'message'?: string;
    /**
     * 
     * @type {UpdateUserPassword422ResponseErrors}
     * @memberof UpdateUserPassword422Response
     */
    'errors'?: UpdateUserPassword422ResponseErrors;
}
/**
 * 
 * @export
 * @interface UpdateUserPassword422ResponseErrors
 */
export interface UpdateUserPassword422ResponseErrors {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserPassword422ResponseErrors
     */
    'old_password'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserPassword422ResponseErrors
     */
    'new_password'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserPassword422ResponseErrors
     */
    'new_password_confirmation'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserPasswordRequest
 */
export interface UpdateUserPasswordRequest {
    /**
     * Current password
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'old_password': string;
    /**
     * New password (minimum 8 characters)
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'new_password': string;
    /**
     * Confirmation of new password
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'new_password_confirmation': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * ID of the user
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * Full name of the user
     * @type {string}
     * @memberof User
     */
    'full_name'?: string;
    /**
     * Gender of the user
     * @type {string}
     * @memberof User
     */
    'gender'?: string;
    /**
     * Birth date of the user
     * @type {string}
     * @memberof User
     */
    'birth_date'?: string;
    /**
     * Email of the user
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * Phone number of the user
     * @type {string}
     * @memberof User
     */
    'phone_number'?: string;
    /**
     * ID of the province
     * @type {number}
     * @memberof User
     */
    'province_id'?: number;
    /**
     * ID of the district
     * @type {number}
     * @memberof User
     */
    'district_id'?: number;
    /**
     * ID of the ward
     * @type {number}
     * @memberof User
     */
    'ward_id'?: number;
    /**
     * Address of the user
     * @type {string}
     * @memberof User
     */
    'address'?: string;
    /**
     * Status of the user
     * @type {string}
     * @memberof User
     */
    'status'?: string;
    /**
     * Number of orders of the user
     * @type {number}
     * @memberof User
     */
    'orders_count'?: number;
}
/**
 * 
 * @export
 * @interface UserCartCartItemIdDelete200Response
 */
export interface UserCartCartItemIdDelete200Response {
    /**
     * 
     * @type {string}
     * @memberof UserCartCartItemIdDelete200Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserCartCartItemIdDelete200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserCartCartItemIdDelete200Response
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface UserCartCartItemIdDelete404Response
 */
export interface UserCartCartItemIdDelete404Response {
    /**
     * 
     * @type {string}
     * @memberof UserCartCartItemIdDelete404Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UserCartGet200Response
 */
export interface UserCartGet200Response {
    /**
     * 
     * @type {string}
     * @memberof UserCartGet200Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserCartGet200Response
     */
    'code'?: number;
    /**
     * 
     * @type {Array<Cart>}
     * @memberof UserCartGet200Response
     */
    'data'?: Array<Cart>;
}
/**
 * 
 * @export
 * @interface UserCartPost201Response
 */
export interface UserCartPost201Response {
    /**
     * 
     * @type {string}
     * @memberof UserCartPost201Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserCartPost201Response
     */
    'code'?: number;
    /**
     * 
     * @type {Cart}
     * @memberof UserCartPost201Response
     */
    'data'?: Cart;
}
/**
 * 
 * @export
 * @interface UserCartPost400Response
 */
export interface UserCartPost400Response {
    /**
     * 
     * @type {string}
     * @memberof UserCartPost400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UserCartPostRequest
 */
export interface UserCartPostRequest {
    /**
     * ID of the book to add to cart
     * @type {number}
     * @memberof UserCartPostRequest
     */
    'book_id': number;
    /**
     * Quantity of the book
     * @type {number}
     * @memberof UserCartPostRequest
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface UserCartPut200Response
 */
export interface UserCartPut200Response {
    /**
     * 
     * @type {string}
     * @memberof UserCartPut200Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserCartPut200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserCartPut200Response
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface UserCartPutRequest
 */
export interface UserCartPutRequest {
    /**
     * 
     * @type {Array<UserCartPutRequestItemsInner>}
     * @memberof UserCartPutRequest
     */
    'items': Array<UserCartPutRequestItemsInner>;
}
/**
 * 
 * @export
 * @interface UserCartPutRequestItemsInner
 */
export interface UserCartPutRequestItemsInner {
    /**
     * ID of the cart item
     * @type {number}
     * @memberof UserCartPutRequestItemsInner
     */
    'id': number;
    /**
     * New quantity for the cart item
     * @type {number}
     * @memberof UserCartPutRequestItemsInner
     */
    'quantity': number;
    /**
     * Due date for returning the book
     * @type {string}
     * @memberof UserCartPutRequestItemsInner
     */
    'return_date_due'?: string;
}
/**
 * 
 * @export
 * @interface UserInfoGet200Response
 */
export interface UserInfoGet200Response {
    /**
     * 
     * @type {string}
     * @memberof UserInfoGet200Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserInfoGet200Response
     */
    'code'?: number;
    /**
     * 
     * @type {Profile}
     * @memberof UserInfoGet200Response
     */
    'data'?: Profile;
}
/**
 * 
 * @export
 * @interface UserInfoPut422Response
 */
export interface UserInfoPut422Response {
    /**
     * 
     * @type {string}
     * @memberof UserInfoPut422Response
     */
    'message'?: string;
    /**
     * 
     * @type {UserInfoPut422ResponseErrors}
     * @memberof UserInfoPut422Response
     */
    'errors'?: UserInfoPut422ResponseErrors;
}
/**
 * 
 * @export
 * @interface UserInfoPut422ResponseErrors
 */
export interface UserInfoPut422ResponseErrors {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserInfoPut422ResponseErrors
     */
    'full_name'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserInfoPutRequest
 */
export interface UserInfoPutRequest {
    /**
     * 
     * @type {string}
     * @memberof UserInfoPutRequest
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoPutRequest
     */
    'phone_number'?: string;
    /**
     * Gender (0 for male, 1 for female, 2 for other)
     * @type {number}
     * @memberof UserInfoPutRequest
     */
    'gender'?: UserInfoPutRequestGenderEnum;
    /**
     * 
     * @type {number}
     * @memberof UserInfoPutRequest
     */
    'province_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserInfoPutRequest
     */
    'district_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserInfoPutRequest
     */
    'ward_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserInfoPutRequest
     */
    'address'?: string;
}

export const UserInfoPutRequestGenderEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type UserInfoPutRequestGenderEnum = typeof UserInfoPutRequestGenderEnum[keyof typeof UserInfoPutRequestGenderEnum];

/**
 * 
 * @export
 * @interface UserWishlistBookIdDelete204Response
 */
export interface UserWishlistBookIdDelete204Response {
    /**
     * 
     * @type {string}
     * @memberof UserWishlistBookIdDelete204Response
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWishlistBookIdDelete204Response
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserWishlistBookIdDelete204Response
     */
    'code'?: number;
}
/**
 * 
 * @export
 * @interface UserWishlistBookIdDelete404Response
 */
export interface UserWishlistBookIdDelete404Response {
    /**
     * 
     * @type {string}
     * @memberof UserWishlistBookIdDelete404Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UserWishlistBookIdPost201Response
 */
export interface UserWishlistBookIdPost201Response {
    /**
     * 
     * @type {string}
     * @memberof UserWishlistBookIdPost201Response
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWishlistBookIdPost201Response
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserWishlistBookIdPost201Response
     */
    'code'?: number;
}
/**
 * 
 * @export
 * @interface UserWishlistBookIdPost400Response
 */
export interface UserWishlistBookIdPost400Response {
    /**
     * 
     * @type {string}
     * @memberof UserWishlistBookIdPost400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UserWishlistBookIdPost404Response
 */
export interface UserWishlistBookIdPost404Response {
    /**
     * 
     * @type {string}
     * @memberof UserWishlistBookIdPost404Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UserWishlistGet200Response
 */
export interface UserWishlistGet200Response {
    /**
     * 
     * @type {string}
     * @memberof UserWishlistGet200Response
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserWishlistGet200Response
     */
    'code'?: number;
    /**
     * 
     * @type {Array<UserWishlistGet200ResponseDataInner>}
     * @memberof UserWishlistGet200Response
     */
    'data'?: Array<UserWishlistGet200ResponseDataInner>;
    /**
     * 
     * @type {UserWishlistGet200ResponsePagination}
     * @memberof UserWishlistGet200Response
     */
    'pagination'?: UserWishlistGet200ResponsePagination;
}
/**
 * 
 * @export
 * @interface UserWishlistGet200ResponseDataInner
 */
export interface UserWishlistGet200ResponseDataInner {
    /**
     * 
     * @type {number}
     * @memberof UserWishlistGet200ResponseDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserWishlistGet200ResponseDataInner
     */
    'full_name'?: string;
    /**
     * 
     * @type {UserWishlistGet200ResponseDataInnerBook}
     * @memberof UserWishlistGet200ResponseDataInner
     */
    'book'?: UserWishlistGet200ResponseDataInnerBook;
}
/**
 * 
 * @export
 * @interface UserWishlistGet200ResponseDataInnerBook
 */
export interface UserWishlistGet200ResponseDataInnerBook {
    /**
     * 
     * @type {number}
     * @memberof UserWishlistGet200ResponseDataInnerBook
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserWishlistGet200ResponseDataInnerBook
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWishlistGet200ResponseDataInnerBook
     */
    'slug'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserWishlistGet200ResponseDataInnerBook
     */
    'category'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserWishlistGet200ResponseDataInnerBook
     */
    'image_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserWishlistGet200ResponseDataInnerBook
     */
    'favorite_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWishlistGet200ResponseDataInnerBook
     */
    'average_star'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWishlistGet200ResponseDataInnerBook
     */
    'review_count'?: number;
}
/**
 * 
 * @export
 * @interface UserWishlistGet200ResponsePagination
 */
export interface UserWishlistGet200ResponsePagination {
    /**
     * 
     * @type {number}
     * @memberof UserWishlistGet200ResponsePagination
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWishlistGet200ResponsePagination
     */
    'total_pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWishlistGet200ResponsePagination
     */
    'current_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserWishlistGet200ResponsePagination
     */
    'per_page'?: number;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update an author
         * @param {number} authorId Author ID
         * @param {PutAuthorRequest} putAuthorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateAuthor: async (authorId: number, putAuthorRequest: PutAuthorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorId' is not null or undefined
            assertParamExists('adminUpdateAuthor', 'authorId', authorId)
            // verify required parameter 'putAuthorRequest' is not null or undefined
            assertParamExists('adminUpdateAuthor', 'putAuthorRequest', putAuthorRequest)
            const localVarPath = `/admin/authors/{author_id}`
                .replace(`{${"author_id"}}`, encodeURIComponent(String(authorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putAuthorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a category
         * @param {number} categoryId Category ID
         * @param {PutCategoryRequest} putCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateCategory: async (categoryId: number, putCategoryRequest: PutCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('adminUpdateCategory', 'categoryId', categoryId)
            // verify required parameter 'putCategoryRequest' is not null or undefined
            assertParamExists('adminUpdateCategory', 'putCategoryRequest', putCategoryRequest)
            const localVarPath = `/admin/categories/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an employee
         * @param {number} employeeId Employee ID
         * @param {PutEmployeeRequest} putEmployeeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateEmployee: async (employeeId: number, putEmployeeRequest: PutEmployeeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            assertParamExists('adminUpdateEmployee', 'employeeId', employeeId)
            // verify required parameter 'putEmployeeRequest' is not null or undefined
            assertParamExists('adminUpdateEmployee', 'putEmployeeRequest', putEmployeeRequest)
            const localVarPath = `/admin/employees/{employee_id}`
                .replace(`{${"employee_id"}}`, encodeURIComponent(String(employeeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putEmployeeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a publisher
         * @param {number} publisherId Publisher ID
         * @param {PutPublisherRequest} putPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdatePublisher: async (publisherId: number, putPublisherRequest: PutPublisherRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publisherId' is not null or undefined
            assertParamExists('adminUpdatePublisher', 'publisherId', publisherId)
            // verify required parameter 'putPublisherRequest' is not null or undefined
            assertParamExists('adminUpdatePublisher', 'putPublisherRequest', putPublisherRequest)
            const localVarPath = `/admin/publishers/{publisher_id}`
                .replace(`{${"publisher_id"}}`, encodeURIComponent(String(publisherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putPublisherRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a review by ID (0 Pending, 1 Approved, 2 Rejected)
         * @summary Update a review
         * @param {number} reviewId The ID of the review to update
         * @param {PutReviewRequest} putReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateReview: async (reviewId: number, putReviewRequest: PutReviewRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewId' is not null or undefined
            assertParamExists('adminUpdateReview', 'reviewId', reviewId)
            // verify required parameter 'putReviewRequest' is not null or undefined
            assertParamExists('adminUpdateReview', 'putReviewRequest', putReviewRequest)
            const localVarPath = `/admin/reviews/{review_id}`
                .replace(`{${"review_id"}}`, encodeURIComponent(String(reviewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user by ID (0 Inactive 1 Active)
         * @summary Update a user
         * @param {number} userId User ID
         * @param {PutUserRequest} putUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser: async (userId: number, putUserRequest: PutUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUpdateUser', 'userId', userId)
            // verify required parameter 'putUserRequest' is not null or undefined
            assertParamExists('adminUpdateUser', 'putUserRequest', putUserRequest)
            const localVarPath = `/admin/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new author
         * @summary Create a new author
         * @param {PostAuthorRequest} postAuthorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthor: async (postAuthorRequest: PostAuthorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postAuthorRequest' is not null or undefined
            assertParamExists('createAuthor', 'postAuthorRequest', postAuthorRequest)
            const localVarPath = `/admin/authors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAuthorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new book
         * @summary Create a new book
         * @param {string} title Title of the book
         * @param {File} imageFile Thumbnail of the book
         * @param {Array<File>} additionalImages Additional images of the book (4 images)
         * @param {Array<number>} author List of author IDs associated with the book
         * @param {number} publisher Publisher ID associated with the book (1 publisher only)
         * @param {Array<number>} category List of category IDs associated with the book
         * @param {number} publishedYear Year the book was published
         * @param {number} stockQuantity Stock quantity of the book
         * @param {number} page Number of pages in the book
         * @param {string} shortDescription Short description of the book
         * @param {string} description Detailed description of the book
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBook: async (title: string, imageFile: File, additionalImages: Array<File>, author: Array<number>, publisher: number, category: Array<number>, publishedYear: number, stockQuantity: number, page: number, shortDescription: string, description: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'title' is not null or undefined
            assertParamExists('createBook', 'title', title)
            // verify required parameter 'imageFile' is not null or undefined
            assertParamExists('createBook', 'imageFile', imageFile)
            // verify required parameter 'additionalImages' is not null or undefined
            assertParamExists('createBook', 'additionalImages', additionalImages)
            // verify required parameter 'author' is not null or undefined
            assertParamExists('createBook', 'author', author)
            // verify required parameter 'publisher' is not null or undefined
            assertParamExists('createBook', 'publisher', publisher)
            // verify required parameter 'category' is not null or undefined
            assertParamExists('createBook', 'category', category)
            // verify required parameter 'publishedYear' is not null or undefined
            assertParamExists('createBook', 'publishedYear', publishedYear)
            // verify required parameter 'stockQuantity' is not null or undefined
            assertParamExists('createBook', 'stockQuantity', stockQuantity)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('createBook', 'page', page)
            // verify required parameter 'shortDescription' is not null or undefined
            assertParamExists('createBook', 'shortDescription', shortDescription)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('createBook', 'description', description)
            const localVarPath = `/admin/books`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
            if (imageFile !== undefined) { 
                localVarFormParams.append('imageFile', imageFile as any);
            }
                if (additionalImages) {
                localVarFormParams.append('additional_images[]', new Blob([JSON.stringify(additionalImages)], { type: "image/*", }));
            }

                if (author) {
                localVarFormParams.append('author', author.join(COLLECTION_FORMATS.csv));
            }

    
            if (publisher !== undefined) { 
                localVarFormParams.append('publisher', publisher as any);
            }
                if (category) {
                localVarFormParams.append('category', category.join(COLLECTION_FORMATS.csv));
            }

    
            if (publishedYear !== undefined) { 
                localVarFormParams.append('published_year', publishedYear as any);
            }
    
            if (stockQuantity !== undefined) { 
                localVarFormParams.append('stock_quantity', stockQuantity as any);
            }
    
            if (page !== undefined) { 
                localVarFormParams.append('page', page as any);
            }
    
            if (shortDescription !== undefined) { 
                localVarFormParams.append('short_description', shortDescription as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new category
         * @summary Create a new category
         * @param {PostCategoryRequest} postCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory: async (postCategoryRequest: PostCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postCategoryRequest' is not null or undefined
            assertParamExists('createCategory', 'postCategoryRequest', postCategoryRequest)
            const localVarPath = `/admin/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new employee
         * @summary Create a new employee
         * @param {PostEmployeeRequest} postEmployeeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmployee: async (postEmployeeRequest: PostEmployeeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postEmployeeRequest' is not null or undefined
            assertParamExists('createEmployee', 'postEmployeeRequest', postEmployeeRequest)
            const localVarPath = `/admin/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postEmployeeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new publisher
         * @summary Create a new publisher
         * @param {PostPublisherRequest} postPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublisher: async (postPublisherRequest: PostPublisherRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postPublisherRequest' is not null or undefined
            assertParamExists('createPublisher', 'postPublisherRequest', postPublisherRequest)
            const localVarPath = `/admin/publishers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postPublisherRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an author by ID
         * @summary Delete an author
         * @param {number} authorId The ID of the author to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthor: async (authorId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorId' is not null or undefined
            assertParamExists('deleteAuthor', 'authorId', authorId)
            const localVarPath = `/admin/authors/{author_id}`
                .replace(`{${"author_id"}}`, encodeURIComponent(String(authorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific book
         * @summary Delete Book
         * @param {number} bookId ID of the book to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBook: async (bookId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('deleteBook', 'bookId', bookId)
            const localVarPath = `/admin/books/{book_id}`
                .replace(`{${"book_id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a category by ID
         * @summary Delete a category
         * @param {number} categoryId The ID of the category to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (categoryId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteCategory', 'categoryId', categoryId)
            const localVarPath = `/admin/categories/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an employee by ID
         * @summary Delete an employee
         * @param {number} employeeId The ID of the employee to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmployee: async (employeeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            assertParamExists('deleteEmployee', 'employeeId', employeeId)
            const localVarPath = `/admin/employees/{employee_id}`
                .replace(`{${"employee_id"}}`, encodeURIComponent(String(employeeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a publisher by ID
         * @summary Delete a publisher
         * @param {number} publisherId The ID of the publisher to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublisher: async (publisherId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publisherId' is not null or undefined
            assertParamExists('deletePublisher', 'publisherId', publisherId)
            const localVarPath = `/admin/publishers/{publisher_id}`
                .replace(`{${"publisher_id"}}`, encodeURIComponent(String(publisherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Authors
         * @summary Get Authors
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthors: async (perPage?: number, searchTerm?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/authors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['search_term'] = searchTerm;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific book by ID
         * @summary Get Book by ID
         * @param {number} bookId ID of the book to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookById: async (bookId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('getBookById', 'bookId', bookId)
            const localVarPath = `/admin/books/{book_id}`
                .replace(`{${"book_id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Books
         * @summary Get Books
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {string} [authorId] 
         * @param {string} [publisherId] 
         * @param {string} [categoryId] 
         * @param {GetBooksIncludeDeletedEnum} [includeDeleted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBooks: async (perPage?: number, searchTerm?: string, authorId?: string, publisherId?: string, categoryId?: string, includeDeleted?: GetBooksIncludeDeletedEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/books`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['search_term'] = searchTerm;
            }

            if (authorId !== undefined) {
                localVarQueryParameter['author_id'] = authorId;
            }

            if (publisherId !== undefined) {
                localVarQueryParameter['publisher_id'] = publisherId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves statistics on books grouped by category
         * @summary Get books by category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBooksByCategory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/dashboard/books-by-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves statistics on book borrowing over the past 12 months
         * @summary Get borrowed books by month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBorrowedBooksByMonth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/dashboard/borrowed-books-by-month`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Categories
         * @summary Get Categories
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (perPage?: number, searchTerm?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['search_term'] = searchTerm;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Employees
         * @summary Get Employees
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployees: async (perPage?: number, searchTerm?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['search_term'] = searchTerm;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of books that have been added to wishlists most frequently
         * @summary Get most favorite books
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMostFavoriteBooks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/dashboard/most-favorite-books`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of orders
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {string} [status] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: async (perPage?: number, searchTerm?: string, status?: string, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['search_term'] = searchTerm;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Publishers
         * @summary Get Publishers
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishers: async (perPage?: number, searchTerm?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/publishers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['search_term'] = searchTerm;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Reviews
         * @summary Get Reviews
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {string} [stars] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviews: async (perPage?: number, searchTerm?: string, stars?: string, status?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['search_term'] = searchTerm;
            }

            if (stars !== undefined) {
                localVarQueryParameter['stars'] = stars;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of top 10 most frequently borrowed books
         * @summary Get top borrowed books
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopBorrowedBooks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/dashboard/top-borrowed-books`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of top 10 users who have borrowed the most books
         * @summary Get top borrowers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopBorrowers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/dashboard/top-borrowers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of users
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {Array<GetUsersStatusEnum>} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (perPage?: number, searchTerm?: string, status?: Array<GetUsersStatusEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['search_term'] = searchTerm;
            }

            if (status) {
                localVarQueryParameter['status'] = status.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import employees from CSV
         * @summary Import employees from CSV
         * @param {File} [file] CSV file containing employee data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEmployees: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/employees/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a soft-deleted book
         * @summary Restore Book
         * @param {number} bookId ID of the book to restore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreBook: async (bookId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('restoreBook', 'bookId', bookId)
            const localVarPath = `/admin/books/{book_id}`
                .replace(`{${"book_id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing book
         * @summary Update Book
         * @param {number} bookId ID of the book to update
         * @param {UpdateBookMethodEnum} method Method spoofing parameter required for Laravel
         * @param {string} title Title of the book
         * @param {string} author Comma-separated list of author IDs associated with the book
         * @param {number} publisher Publisher ID associated with the book (1 publisher only)
         * @param {string} category Comma-separated list of category IDs associated with the book
         * @param {number} publishedYear Year the book was published
         * @param {number} stockQuantity Stock quantity of the book
         * @param {number} page Number of pages in the book
         * @param {string} shortDescription Short description of the book
         * @param {string} description Detailed description of the book
         * @param {File} [imageFile] Thumbnail of the book
         * @param {Array<File>} [additionalImages] Additional images of the book (4 images)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBook: async (bookId: number, method: UpdateBookMethodEnum, title: string, author: string, publisher: number, category: string, publishedYear: number, stockQuantity: number, page: number, shortDescription: string, description: string, imageFile?: File, additionalImages?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('updateBook', 'bookId', bookId)
            // verify required parameter 'method' is not null or undefined
            assertParamExists('updateBook', 'method', method)
            // verify required parameter 'title' is not null or undefined
            assertParamExists('updateBook', 'title', title)
            // verify required parameter 'author' is not null or undefined
            assertParamExists('updateBook', 'author', author)
            // verify required parameter 'publisher' is not null or undefined
            assertParamExists('updateBook', 'publisher', publisher)
            // verify required parameter 'category' is not null or undefined
            assertParamExists('updateBook', 'category', category)
            // verify required parameter 'publishedYear' is not null or undefined
            assertParamExists('updateBook', 'publishedYear', publishedYear)
            // verify required parameter 'stockQuantity' is not null or undefined
            assertParamExists('updateBook', 'stockQuantity', stockQuantity)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('updateBook', 'page', page)
            // verify required parameter 'shortDescription' is not null or undefined
            assertParamExists('updateBook', 'shortDescription', shortDescription)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('updateBook', 'description', description)
            const localVarPath = `/admin/books/{book_id}`
                .replace(`{${"book_id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (method !== undefined) {
                localVarQueryParameter['_method'] = method;
            }


            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
            if (imageFile !== undefined) { 
                localVarFormParams.append('imageFile', imageFile as any);
            }
                if (additionalImages) {
                localVarFormParams.append('additional_images[]', new Blob([JSON.stringify(additionalImages)], { type: "image/*", }));
            }

    
            if (author !== undefined) { 
                localVarFormParams.append('author', author as any);
            }
    
            if (publisher !== undefined) { 
                localVarFormParams.append('publisher', publisher as any);
            }
    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
            if (publishedYear !== undefined) { 
                localVarFormParams.append('published_year', publishedYear as any);
            }
    
            if (stockQuantity !== undefined) { 
                localVarFormParams.append('stock_quantity', stockQuantity as any);
            }
    
            if (page !== undefined) { 
                localVarFormParams.append('page', page as any);
            }
    
            if (shortDescription !== undefined) { 
                localVarFormParams.append('short_description', shortDescription as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of an order and its items
         * @summary Update order status
         * @param {number} orderId ID of the order to update
         * @param {UpdateOrderRequest} updateOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder: async (orderId: number, updateOrderRequest: UpdateOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('updateOrder', 'orderId', orderId)
            // verify required parameter 'updateOrderRequest' is not null or undefined
            assertParamExists('updateOrder', 'updateOrderRequest', updateOrderRequest)
            const localVarPath = `/admin/orders/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update an author
         * @param {number} authorId Author ID
         * @param {PutAuthorRequest} putAuthorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateAuthor(authorId: number, putAuthorRequest: PutAuthorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAuthor200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateAuthor(authorId, putAuthorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateAuthor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a category
         * @param {number} categoryId Category ID
         * @param {PutCategoryRequest} putCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateCategory(categoryId: number, putCategoryRequest: PutCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateCategory(categoryId, putCategoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an employee
         * @param {number} employeeId Employee ID
         * @param {PutEmployeeRequest} putEmployeeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateEmployee(employeeId: number, putEmployeeRequest: PutEmployeeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEmployee200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateEmployee(employeeId, putEmployeeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateEmployee']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a publisher
         * @param {number} publisherId Publisher ID
         * @param {PutPublisherRequest} putPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdatePublisher(publisherId: number, putPublisherRequest: PutPublisherRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublisher200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdatePublisher(publisherId, putPublisherRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdatePublisher']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a review by ID (0 Pending, 1 Approved, 2 Rejected)
         * @summary Update a review
         * @param {number} reviewId The ID of the review to update
         * @param {PutReviewRequest} putReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateReview(reviewId: number, putReviewRequest: PutReviewRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUpdateReview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateReview(reviewId, putReviewRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a user by ID (0 Inactive 1 Active)
         * @summary Update a user
         * @param {number} userId User ID
         * @param {PutUserRequest} putUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateUser(userId: number, putUserRequest: PutUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUpdateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateUser(userId, putUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new author
         * @summary Create a new author
         * @param {PostAuthorRequest} postAuthorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthor(postAuthorRequest: PostAuthorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAuthor200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthor(postAuthorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.createAuthor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new book
         * @summary Create a new book
         * @param {string} title Title of the book
         * @param {File} imageFile Thumbnail of the book
         * @param {Array<File>} additionalImages Additional images of the book (4 images)
         * @param {Array<number>} author List of author IDs associated with the book
         * @param {number} publisher Publisher ID associated with the book (1 publisher only)
         * @param {Array<number>} category List of category IDs associated with the book
         * @param {number} publishedYear Year the book was published
         * @param {number} stockQuantity Stock quantity of the book
         * @param {number} page Number of pages in the book
         * @param {string} shortDescription Short description of the book
         * @param {string} description Detailed description of the book
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBook(title: string, imageFile: File, additionalImages: Array<File>, author: Array<number>, publisher: number, category: Array<number>, publishedYear: number, stockQuantity: number, page: number, shortDescription: string, description: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBook(title, imageFile, additionalImages, author, publisher, category, publishedYear, stockQuantity, page, shortDescription, description, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.createBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new category
         * @summary Create a new category
         * @param {PostCategoryRequest} postCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategory(postCategoryRequest: PostCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(postCategoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.createCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new employee
         * @summary Create a new employee
         * @param {PostEmployeeRequest} postEmployeeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmployee(postEmployeeRequest: PostEmployeeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEmployee200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmployee(postEmployeeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.createEmployee']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new publisher
         * @summary Create a new publisher
         * @param {PostPublisherRequest} postPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublisher(postPublisherRequest: PostPublisherRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublisher200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublisher(postPublisherRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.createPublisher']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an author by ID
         * @summary Delete an author
         * @param {number} authorId The ID of the author to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthor(authorId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAuthor200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAuthor(authorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteAuthor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific book
         * @summary Delete Book
         * @param {number} bookId ID of the book to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBook(bookId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteBook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBook(bookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a category by ID
         * @summary Delete a category
         * @param {number} categoryId The ID of the category to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(categoryId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an employee by ID
         * @summary Delete an employee
         * @param {number} employeeId The ID of the employee to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEmployee(employeeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteEmployee200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEmployee(employeeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteEmployee']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a publisher by ID
         * @summary Delete a publisher
         * @param {number} publisherId The ID of the publisher to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublisher(publisherId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletePublisher200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublisher(publisherId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deletePublisher']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Authors
         * @summary Get Authors
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthors(perPage?: number, searchTerm?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuthors200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthors(perPage, searchTerm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getAuthors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific book by ID
         * @summary Get Book by ID
         * @param {number} bookId ID of the book to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookById(bookId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBookById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookById(bookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getBookById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Books
         * @summary Get Books
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {string} [authorId] 
         * @param {string} [publisherId] 
         * @param {string} [categoryId] 
         * @param {GetBooksIncludeDeletedEnum} [includeDeleted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBooks(perPage?: number, searchTerm?: string, authorId?: string, publisherId?: string, categoryId?: string, includeDeleted?: GetBooksIncludeDeletedEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBooks(perPage, searchTerm, authorId, publisherId, categoryId, includeDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getBooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves statistics on books grouped by category
         * @summary Get books by category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBooksByCategory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBooksByCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBooksByCategory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getBooksByCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves statistics on book borrowing over the past 12 months
         * @summary Get borrowed books by month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBorrowedBooksByMonth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBorrowedBooksByMonth200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBorrowedBooksByMonth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getBorrowedBooksByMonth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Categories
         * @summary Get Categories
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(perPage?: number, searchTerm?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCategories200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(perPage, searchTerm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Employees
         * @summary Get Employees
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmployees(perPage?: number, searchTerm?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEmployees200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmployees(perPage, searchTerm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getEmployees']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of books that have been added to wishlists most frequently
         * @summary Get most favorite books
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMostFavoriteBooks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMostFavoriteBooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMostFavoriteBooks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getMostFavoriteBooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of orders
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {string} [status] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrders(perPage?: number, searchTerm?: string, status?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(perPage, searchTerm, status, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Publishers
         * @summary Get Publishers
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishers(perPage?: number, searchTerm?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPublishers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishers(perPage, searchTerm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getPublishers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Reviews
         * @summary Get Reviews
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {string} [stars] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviews(perPage?: number, searchTerm?: string, stars?: string, status?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReviews200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviews(perPage, searchTerm, stars, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getReviews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of top 10 most frequently borrowed books
         * @summary Get top borrowed books
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopBorrowedBooks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTopBorrowedBooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopBorrowedBooks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getTopBorrowedBooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of top 10 users who have borrowed the most books
         * @summary Get top borrowers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopBorrowers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTopBorrowers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopBorrowers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getTopBorrowers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of users
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {Array<GetUsersStatusEnum>} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(perPage?: number, searchTerm?: string, status?: Array<GetUsersStatusEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(perPage, searchTerm, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import employees from CSV
         * @summary Import employees from CSV
         * @param {File} [file] CSV file containing employee data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importEmployees(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportEmployees200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importEmployees(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.importEmployees']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore a soft-deleted book
         * @summary Restore Book
         * @param {number} bookId ID of the book to restore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreBook(bookId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreBook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreBook(bookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.restoreBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing book
         * @summary Update Book
         * @param {number} bookId ID of the book to update
         * @param {UpdateBookMethodEnum} method Method spoofing parameter required for Laravel
         * @param {string} title Title of the book
         * @param {string} author Comma-separated list of author IDs associated with the book
         * @param {number} publisher Publisher ID associated with the book (1 publisher only)
         * @param {string} category Comma-separated list of category IDs associated with the book
         * @param {number} publishedYear Year the book was published
         * @param {number} stockQuantity Stock quantity of the book
         * @param {number} page Number of pages in the book
         * @param {string} shortDescription Short description of the book
         * @param {string} description Detailed description of the book
         * @param {File} [imageFile] Thumbnail of the book
         * @param {Array<File>} [additionalImages] Additional images of the book (4 images)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBook(bookId: number, method: UpdateBookMethodEnum, title: string, author: string, publisher: number, category: string, publishedYear: number, stockQuantity: number, page: number, shortDescription: string, description: string, imageFile?: File, additionalImages?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBookById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBook(bookId, method, title, author, publisher, category, publishedYear, stockQuantity, page, shortDescription, description, imageFile, additionalImages, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.updateBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the status of an order and its items
         * @summary Update order status
         * @param {number} orderId ID of the order to update
         * @param {UpdateOrderRequest} updateOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrder(orderId: number, updateOrderRequest: UpdateOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrder(orderId, updateOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.updateOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Update an author
         * @param {number} authorId Author ID
         * @param {PutAuthorRequest} putAuthorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateAuthor(authorId: number, putAuthorRequest: PutAuthorRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAuthor200Response> {
            return localVarFp.adminUpdateAuthor(authorId, putAuthorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a category
         * @param {number} categoryId Category ID
         * @param {PutCategoryRequest} putCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateCategory(categoryId: number, putCategoryRequest: PutCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateCategory200Response> {
            return localVarFp.adminUpdateCategory(categoryId, putCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an employee
         * @param {number} employeeId Employee ID
         * @param {PutEmployeeRequest} putEmployeeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateEmployee(employeeId: number, putEmployeeRequest: PutEmployeeRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateEmployee200Response> {
            return localVarFp.adminUpdateEmployee(employeeId, putEmployeeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a publisher
         * @param {number} publisherId Publisher ID
         * @param {PutPublisherRequest} putPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdatePublisher(publisherId: number, putPublisherRequest: PutPublisherRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePublisher200Response> {
            return localVarFp.adminUpdatePublisher(publisherId, putPublisherRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a review by ID (0 Pending, 1 Approved, 2 Rejected)
         * @summary Update a review
         * @param {number} reviewId The ID of the review to update
         * @param {PutReviewRequest} putReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateReview(reviewId: number, putReviewRequest: PutReviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminUpdateReview200Response> {
            return localVarFp.adminUpdateReview(reviewId, putReviewRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user by ID (0 Inactive 1 Active)
         * @summary Update a user
         * @param {number} userId User ID
         * @param {PutUserRequest} putUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser(userId: number, putUserRequest: PutUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminUpdateUser200Response> {
            return localVarFp.adminUpdateUser(userId, putUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new author
         * @summary Create a new author
         * @param {PostAuthorRequest} postAuthorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthor(postAuthorRequest: PostAuthorRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAuthor200Response> {
            return localVarFp.createAuthor(postAuthorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new book
         * @summary Create a new book
         * @param {string} title Title of the book
         * @param {File} imageFile Thumbnail of the book
         * @param {Array<File>} additionalImages Additional images of the book (4 images)
         * @param {Array<number>} author List of author IDs associated with the book
         * @param {number} publisher Publisher ID associated with the book (1 publisher only)
         * @param {Array<number>} category List of category IDs associated with the book
         * @param {number} publishedYear Year the book was published
         * @param {number} stockQuantity Stock quantity of the book
         * @param {number} page Number of pages in the book
         * @param {string} shortDescription Short description of the book
         * @param {string} description Detailed description of the book
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBook(title: string, imageFile: File, additionalImages: Array<File>, author: Array<number>, publisher: number, category: Array<number>, publishedYear: number, stockQuantity: number, page: number, shortDescription: string, description: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateBook200Response> {
            return localVarFp.createBook(title, imageFile, additionalImages, author, publisher, category, publishedYear, stockQuantity, page, shortDescription, description, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new category
         * @summary Create a new category
         * @param {PostCategoryRequest} postCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(postCategoryRequest: PostCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateCategory200Response> {
            return localVarFp.createCategory(postCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new employee
         * @summary Create a new employee
         * @param {PostEmployeeRequest} postEmployeeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmployee(postEmployeeRequest: PostEmployeeRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateEmployee200Response> {
            return localVarFp.createEmployee(postEmployeeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new publisher
         * @summary Create a new publisher
         * @param {PostPublisherRequest} postPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublisher(postPublisherRequest: PostPublisherRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePublisher200Response> {
            return localVarFp.createPublisher(postPublisherRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an author by ID
         * @summary Delete an author
         * @param {number} authorId The ID of the author to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthor(authorId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAuthor200Response> {
            return localVarFp.deleteAuthor(authorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific book
         * @summary Delete Book
         * @param {number} bookId ID of the book to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBook(bookId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteBook200Response> {
            return localVarFp.deleteBook(bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a category by ID
         * @summary Delete a category
         * @param {number} categoryId The ID of the category to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(categoryId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteCategory200Response> {
            return localVarFp.deleteCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an employee by ID
         * @summary Delete an employee
         * @param {number} employeeId The ID of the employee to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmployee(employeeId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteEmployee200Response> {
            return localVarFp.deleteEmployee(employeeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a publisher by ID
         * @summary Delete a publisher
         * @param {number} publisherId The ID of the publisher to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublisher(publisherId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeletePublisher200Response> {
            return localVarFp.deletePublisher(publisherId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Authors
         * @summary Get Authors
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthors(perPage?: number, searchTerm?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAuthors200Response> {
            return localVarFp.getAuthors(perPage, searchTerm, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific book by ID
         * @summary Get Book by ID
         * @param {number} bookId ID of the book to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookById(bookId: number, options?: RawAxiosRequestConfig): AxiosPromise<GetBookById200Response> {
            return localVarFp.getBookById(bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Books
         * @summary Get Books
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {string} [authorId] 
         * @param {string} [publisherId] 
         * @param {string} [categoryId] 
         * @param {GetBooksIncludeDeletedEnum} [includeDeleted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBooks(perPage?: number, searchTerm?: string, authorId?: string, publisherId?: string, categoryId?: string, includeDeleted?: GetBooksIncludeDeletedEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetBooks200Response> {
            return localVarFp.getBooks(perPage, searchTerm, authorId, publisherId, categoryId, includeDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves statistics on books grouped by category
         * @summary Get books by category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBooksByCategory(options?: RawAxiosRequestConfig): AxiosPromise<GetBooksByCategory200Response> {
            return localVarFp.getBooksByCategory(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves statistics on book borrowing over the past 12 months
         * @summary Get borrowed books by month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBorrowedBooksByMonth(options?: RawAxiosRequestConfig): AxiosPromise<GetBorrowedBooksByMonth200Response> {
            return localVarFp.getBorrowedBooksByMonth(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Categories
         * @summary Get Categories
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(perPage?: number, searchTerm?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCategories200Response> {
            return localVarFp.getCategories(perPage, searchTerm, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Employees
         * @summary Get Employees
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployees(perPage?: number, searchTerm?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetEmployees200Response> {
            return localVarFp.getEmployees(perPage, searchTerm, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of books that have been added to wishlists most frequently
         * @summary Get most favorite books
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMostFavoriteBooks(options?: RawAxiosRequestConfig): AxiosPromise<GetMostFavoriteBooks200Response> {
            return localVarFp.getMostFavoriteBooks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of orders
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {string} [status] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(perPage?: number, searchTerm?: string, status?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetOrders200Response> {
            return localVarFp.getOrders(perPage, searchTerm, status, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Publishers
         * @summary Get Publishers
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishers(perPage?: number, searchTerm?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetPublishers200Response> {
            return localVarFp.getPublishers(perPage, searchTerm, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Reviews
         * @summary Get Reviews
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {string} [stars] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviews(perPage?: number, searchTerm?: string, stars?: string, status?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetReviews200Response> {
            return localVarFp.getReviews(perPage, searchTerm, stars, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of top 10 most frequently borrowed books
         * @summary Get top borrowed books
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopBorrowedBooks(options?: RawAxiosRequestConfig): AxiosPromise<GetTopBorrowedBooks200Response> {
            return localVarFp.getTopBorrowedBooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of top 10 users who have borrowed the most books
         * @summary Get top borrowers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopBorrowers(options?: RawAxiosRequestConfig): AxiosPromise<GetTopBorrowers200Response> {
            return localVarFp.getTopBorrowers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of users
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {Array<GetUsersStatusEnum>} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(perPage?: number, searchTerm?: string, status?: Array<GetUsersStatusEnum>, options?: RawAxiosRequestConfig): AxiosPromise<GetUsers200Response> {
            return localVarFp.getUsers(perPage, searchTerm, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Import employees from CSV
         * @summary Import employees from CSV
         * @param {File} [file] CSV file containing employee data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEmployees(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<ImportEmployees200Response> {
            return localVarFp.importEmployees(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a soft-deleted book
         * @summary Restore Book
         * @param {number} bookId ID of the book to restore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreBook(bookId: number, options?: RawAxiosRequestConfig): AxiosPromise<RestoreBook200Response> {
            return localVarFp.restoreBook(bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing book
         * @summary Update Book
         * @param {number} bookId ID of the book to update
         * @param {UpdateBookMethodEnum} method Method spoofing parameter required for Laravel
         * @param {string} title Title of the book
         * @param {string} author Comma-separated list of author IDs associated with the book
         * @param {number} publisher Publisher ID associated with the book (1 publisher only)
         * @param {string} category Comma-separated list of category IDs associated with the book
         * @param {number} publishedYear Year the book was published
         * @param {number} stockQuantity Stock quantity of the book
         * @param {number} page Number of pages in the book
         * @param {string} shortDescription Short description of the book
         * @param {string} description Detailed description of the book
         * @param {File} [imageFile] Thumbnail of the book
         * @param {Array<File>} [additionalImages] Additional images of the book (4 images)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBook(bookId: number, method: UpdateBookMethodEnum, title: string, author: string, publisher: number, category: string, publishedYear: number, stockQuantity: number, page: number, shortDescription: string, description: string, imageFile?: File, additionalImages?: Array<File>, options?: RawAxiosRequestConfig): AxiosPromise<GetBookById200Response> {
            return localVarFp.updateBook(bookId, method, title, author, publisher, category, publishedYear, stockQuantity, page, shortDescription, description, imageFile, additionalImages, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of an order and its items
         * @summary Update order status
         * @param {number} orderId ID of the order to update
         * @param {UpdateOrderRequest} updateOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(orderId: number, updateOrderRequest: UpdateOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateOrder200Response> {
            return localVarFp.updateOrder(orderId, updateOrderRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary Update an author
     * @param {number} authorId Author ID
     * @param {PutAuthorRequest} putAuthorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateAuthor(authorId: number, putAuthorRequest: PutAuthorRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateAuthor(authorId, putAuthorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a category
     * @param {number} categoryId Category ID
     * @param {PutCategoryRequest} putCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateCategory(categoryId: number, putCategoryRequest: PutCategoryRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateCategory(categoryId, putCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an employee
     * @param {number} employeeId Employee ID
     * @param {PutEmployeeRequest} putEmployeeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateEmployee(employeeId: number, putEmployeeRequest: PutEmployeeRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateEmployee(employeeId, putEmployeeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a publisher
     * @param {number} publisherId Publisher ID
     * @param {PutPublisherRequest} putPublisherRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdatePublisher(publisherId: number, putPublisherRequest: PutPublisherRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdatePublisher(publisherId, putPublisherRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a review by ID (0 Pending, 1 Approved, 2 Rejected)
     * @summary Update a review
     * @param {number} reviewId The ID of the review to update
     * @param {PutReviewRequest} putReviewRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateReview(reviewId: number, putReviewRequest: PutReviewRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateReview(reviewId, putReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user by ID (0 Inactive 1 Active)
     * @summary Update a user
     * @param {number} userId User ID
     * @param {PutUserRequest} putUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateUser(userId: number, putUserRequest: PutUserRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateUser(userId, putUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new author
     * @summary Create a new author
     * @param {PostAuthorRequest} postAuthorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createAuthor(postAuthorRequest: PostAuthorRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).createAuthor(postAuthorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new book
     * @summary Create a new book
     * @param {string} title Title of the book
     * @param {File} imageFile Thumbnail of the book
     * @param {Array<File>} additionalImages Additional images of the book (4 images)
     * @param {Array<number>} author List of author IDs associated with the book
     * @param {number} publisher Publisher ID associated with the book (1 publisher only)
     * @param {Array<number>} category List of category IDs associated with the book
     * @param {number} publishedYear Year the book was published
     * @param {number} stockQuantity Stock quantity of the book
     * @param {number} page Number of pages in the book
     * @param {string} shortDescription Short description of the book
     * @param {string} description Detailed description of the book
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createBook(title: string, imageFile: File, additionalImages: Array<File>, author: Array<number>, publisher: number, category: Array<number>, publishedYear: number, stockQuantity: number, page: number, shortDescription: string, description: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).createBook(title, imageFile, additionalImages, author, publisher, category, publishedYear, stockQuantity, page, shortDescription, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new category
     * @summary Create a new category
     * @param {PostCategoryRequest} postCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createCategory(postCategoryRequest: PostCategoryRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).createCategory(postCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new employee
     * @summary Create a new employee
     * @param {PostEmployeeRequest} postEmployeeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createEmployee(postEmployeeRequest: PostEmployeeRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).createEmployee(postEmployeeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new publisher
     * @summary Create a new publisher
     * @param {PostPublisherRequest} postPublisherRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createPublisher(postPublisherRequest: PostPublisherRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).createPublisher(postPublisherRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an author by ID
     * @summary Delete an author
     * @param {number} authorId The ID of the author to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteAuthor(authorId: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteAuthor(authorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific book
     * @summary Delete Book
     * @param {number} bookId ID of the book to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteBook(bookId: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteBook(bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a category by ID
     * @summary Delete a category
     * @param {number} categoryId The ID of the category to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteCategory(categoryId: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an employee by ID
     * @summary Delete an employee
     * @param {number} employeeId The ID of the employee to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteEmployee(employeeId: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteEmployee(employeeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a publisher by ID
     * @summary Delete a publisher
     * @param {number} publisherId The ID of the publisher to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deletePublisher(publisherId: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deletePublisher(publisherId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Authors
     * @summary Get Authors
     * @param {number} [perPage] 
     * @param {string} [searchTerm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getAuthors(perPage?: number, searchTerm?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getAuthors(perPage, searchTerm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific book by ID
     * @summary Get Book by ID
     * @param {number} bookId ID of the book to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getBookById(bookId: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getBookById(bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Books
     * @summary Get Books
     * @param {number} [perPage] 
     * @param {string} [searchTerm] 
     * @param {string} [authorId] 
     * @param {string} [publisherId] 
     * @param {string} [categoryId] 
     * @param {GetBooksIncludeDeletedEnum} [includeDeleted] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getBooks(perPage?: number, searchTerm?: string, authorId?: string, publisherId?: string, categoryId?: string, includeDeleted?: GetBooksIncludeDeletedEnum, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getBooks(perPage, searchTerm, authorId, publisherId, categoryId, includeDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves statistics on books grouped by category
     * @summary Get books by category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getBooksByCategory(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getBooksByCategory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves statistics on book borrowing over the past 12 months
     * @summary Get borrowed books by month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getBorrowedBooksByMonth(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getBorrowedBooksByMonth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Categories
     * @summary Get Categories
     * @param {number} [perPage] 
     * @param {string} [searchTerm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getCategories(perPage?: number, searchTerm?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getCategories(perPage, searchTerm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Employees
     * @summary Get Employees
     * @param {number} [perPage] 
     * @param {string} [searchTerm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getEmployees(perPage?: number, searchTerm?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getEmployees(perPage, searchTerm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of books that have been added to wishlists most frequently
     * @summary Get most favorite books
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getMostFavoriteBooks(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getMostFavoriteBooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of orders
     * @param {number} [perPage] 
     * @param {string} [searchTerm] 
     * @param {string} [status] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getOrders(perPage?: number, searchTerm?: string, status?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getOrders(perPage, searchTerm, status, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Publishers
     * @summary Get Publishers
     * @param {number} [perPage] 
     * @param {string} [searchTerm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getPublishers(perPage?: number, searchTerm?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getPublishers(perPage, searchTerm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Reviews
     * @summary Get Reviews
     * @param {number} [perPage] 
     * @param {string} [searchTerm] 
     * @param {string} [stars] 
     * @param {string} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getReviews(perPage?: number, searchTerm?: string, stars?: string, status?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getReviews(perPage, searchTerm, stars, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of top 10 most frequently borrowed books
     * @summary Get top borrowed books
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getTopBorrowedBooks(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getTopBorrowedBooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of top 10 users who have borrowed the most books
     * @summary Get top borrowers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getTopBorrowers(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getTopBorrowers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of users
     * @param {number} [perPage] 
     * @param {string} [searchTerm] 
     * @param {Array<GetUsersStatusEnum>} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUsers(perPage?: number, searchTerm?: string, status?: Array<GetUsersStatusEnum>, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUsers(perPage, searchTerm, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import employees from CSV
     * @summary Import employees from CSV
     * @param {File} [file] CSV file containing employee data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public importEmployees(file?: File, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).importEmployees(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a soft-deleted book
     * @summary Restore Book
     * @param {number} bookId ID of the book to restore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public restoreBook(bookId: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).restoreBook(bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing book
     * @summary Update Book
     * @param {number} bookId ID of the book to update
     * @param {UpdateBookMethodEnum} method Method spoofing parameter required for Laravel
     * @param {string} title Title of the book
     * @param {string} author Comma-separated list of author IDs associated with the book
     * @param {number} publisher Publisher ID associated with the book (1 publisher only)
     * @param {string} category Comma-separated list of category IDs associated with the book
     * @param {number} publishedYear Year the book was published
     * @param {number} stockQuantity Stock quantity of the book
     * @param {number} page Number of pages in the book
     * @param {string} shortDescription Short description of the book
     * @param {string} description Detailed description of the book
     * @param {File} [imageFile] Thumbnail of the book
     * @param {Array<File>} [additionalImages] Additional images of the book (4 images)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateBook(bookId: number, method: UpdateBookMethodEnum, title: string, author: string, publisher: number, category: string, publishedYear: number, stockQuantity: number, page: number, shortDescription: string, description: string, imageFile?: File, additionalImages?: Array<File>, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateBook(bookId, method, title, author, publisher, category, publishedYear, stockQuantity, page, shortDescription, description, imageFile, additionalImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of an order and its items
     * @summary Update order status
     * @param {number} orderId ID of the order to update
     * @param {UpdateOrderRequest} updateOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateOrder(orderId: number, updateOrderRequest: UpdateOrderRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateOrder(orderId, updateOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetBooksIncludeDeletedEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;
export type GetBooksIncludeDeletedEnum = typeof GetBooksIncludeDeletedEnum[keyof typeof GetBooksIncludeDeletedEnum];
/**
 * @export
 */
export const GetUsersStatusEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;
export type GetUsersStatusEnum = typeof GetUsersStatusEnum[keyof typeof GetUsersStatusEnum];
/**
 * @export
 */
export const UpdateBookMethodEnum = {
    Put: 'PUT'
} as const;
export type UpdateBookMethodEnum = typeof UpdateBookMethodEnum[keyof typeof UpdateBookMethodEnum];


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Request a password reset link
         * @summary Forgot Password
         * @param {AuthForgotPasswordRequest} authForgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (authForgotPasswordRequest: AuthForgotPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authForgotPasswordRequest' is not null or undefined
            assertParamExists('forgotPassword', 'authForgotPasswordRequest', authForgotPasswordRequest)
            const localVarPath = `/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authForgotPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (authLoginRequest: AuthLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLoginRequest' is not null or undefined
            assertParamExists('login', 'authLoginRequest', authLoginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user using Google OAuth token
         * @summary Login with Google
         * @param {LoginGoogleRequest} loginGoogleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginGoogle: async (loginGoogleRequest: LoginGoogleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginGoogleRequest' is not null or undefined
            assertParamExists('loginGoogle', 'loginGoogleRequest', loginGoogleRequest)
            const localVarPath = `/auth/login-google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginGoogleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Profile
         * @summary Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset Password
         * @summary Reset Password
         * @param {AuthResetPasswordRequest} authResetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (authResetPasswordRequest: AuthResetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authResetPasswordRequest' is not null or undefined
            assertParamExists('resetPassword', 'authResetPasswordRequest', authResetPasswordRequest)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authResetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Signup
         * @param {AuthSignupRequest} authSignupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (authSignupRequest: AuthSignupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authSignupRequest' is not null or undefined
            assertParamExists('signup', 'authSignupRequest', authSignupRequest)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSignupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Request a password reset link
         * @summary Forgot Password
         * @param {AuthForgotPasswordRequest} authForgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(authForgotPasswordRequest: AuthForgotPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgotPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(authForgotPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.forgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(authLoginRequest: AuthLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Login200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(authLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate a user using Google OAuth token
         * @summary Login with Google
         * @param {LoginGoogleRequest} loginGoogleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginGoogle(loginGoogleRequest: LoginGoogleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginGoogle200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginGoogle(loginGoogleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logout
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Logout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Profile
         * @summary Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.profile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset Password
         * @summary Reset Password
         * @param {AuthResetPasswordRequest} authResetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(authResetPasswordRequest: AuthResetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResetPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(authResetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Signup
         * @param {AuthSignupRequest} authSignupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(authSignupRequest: AuthSignupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Login200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signup(authSignupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.signup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Request a password reset link
         * @summary Forgot Password
         * @param {AuthForgotPasswordRequest} authForgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(authForgotPasswordRequest: AuthForgotPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<ForgotPassword200Response> {
            return localVarFp.forgotPassword(authForgotPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(authLoginRequest: AuthLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<Login200Response> {
            return localVarFp.login(authLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user using Google OAuth token
         * @summary Login with Google
         * @param {LoginGoogleRequest} loginGoogleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginGoogle(loginGoogleRequest: LoginGoogleRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginGoogle200Response> {
            return localVarFp.loginGoogle(loginGoogleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<Logout200Response> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Profile
         * @summary Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile(options?: RawAxiosRequestConfig): AxiosPromise<Profile200Response> {
            return localVarFp.profile(options).then((request) => request(axios, basePath));
        },
        /**
         * Reset Password
         * @summary Reset Password
         * @param {AuthResetPasswordRequest} authResetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(authResetPasswordRequest: AuthResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResetPassword200Response> {
            return localVarFp.resetPassword(authResetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Signup
         * @param {AuthSignupRequest} authSignupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(authSignupRequest: AuthSignupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Login200Response> {
            return localVarFp.signup(authSignupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Request a password reset link
     * @summary Forgot Password
     * @param {AuthForgotPasswordRequest} authForgotPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public forgotPassword(authForgotPasswordRequest: AuthForgotPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).forgotPassword(authForgotPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {AuthLoginRequest} authLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(authLoginRequest: AuthLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(authLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user using Google OAuth token
     * @summary Login with Google
     * @param {LoginGoogleRequest} loginGoogleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginGoogle(loginGoogleRequest: LoginGoogleRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginGoogle(loginGoogleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Profile
     * @summary Profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public profile(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).profile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset Password
     * @summary Reset Password
     * @param {AuthResetPasswordRequest} authResetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public resetPassword(authResetPasswordRequest: AuthResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).resetPassword(authResetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Signup
     * @param {AuthSignupRequest} authSignupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signup(authSignupRequest: AuthSignupRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).signup(authSignupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Process the checkout for the user\'s cart
         * @summary Checkout cart
         * @param {AdminOrdersPostRequest} adminOrdersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOrdersPost: async (adminOrdersPostRequest: AdminOrdersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminOrdersPostRequest' is not null or undefined
            assertParamExists('adminOrdersPost', 'adminOrdersPostRequest', adminOrdersPostRequest)
            const localVarPath = `/admin/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminOrdersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a new review for a book
         * @summary Create a new review
         * @param {CreateBookReviewRequest} createBookReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookReview: async (createBookReviewRequest: CreateBookReviewRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBookReviewRequest' is not null or undefined
            assertParamExists('createBookReview', 'createBookReviewRequest', createBookReviewRequest)
            const localVarPath = `/admin/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBookReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of districts for a given province ID
         * @summary Get districts by province ID
         * @param {number} provinceId ID of the province to get districts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistricts: async (provinceId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceId' is not null or undefined
            assertParamExists('getDistricts', 'provinceId', provinceId)
            const localVarPath = `/user/location/districts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (provinceId !== undefined) {
                localVarQueryParameter['provinceId'] = provinceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current user\'s order/borrowing history with optional filters (0 Borrowing, 1 Returned, 2 Overdue, 3 Lost)
         * @summary Get user\'s borrowing history
         * @param {number} [perPage] 
         * @param {string} [status] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderByUser: async (perPage?: number, status?: string, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/orders/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all provinces
         * @summary Get all provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvinces: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/location/provinces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get books related to a specific book identified by slug
         * @summary Get Related Books
         * @param {string} bookSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedBooks: async (bookSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookSlug' is not null or undefined
            assertParamExists('getRelatedBooks', 'bookSlug', bookSlug)
            const localVarPath = `/user/books/{book_slug}/related-books`
                .replace(`{${"book_slug"}}`, encodeURIComponent(String(bookSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Books
         * @summary Get Books
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {string} [authorSlug] 
         * @param {string} [publisherSlug] 
         * @param {string} [categorySlug] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBooks: async (perPage?: number, searchTerm?: string, authorSlug?: string, publisherSlug?: string, categorySlug?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/books`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['search_term'] = searchTerm;
            }

            if (authorSlug !== undefined) {
                localVarQueryParameter['author_slug'] = authorSlug;
            }

            if (publisherSlug !== undefined) {
                localVarQueryParameter['publisher_slug'] = publisherSlug;
            }

            if (categorySlug !== undefined) {
                localVarQueryParameter['category_slug'] = categorySlug;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of wards for a given district ID
         * @summary Get wards by district ID
         * @param {number} districtId ID of the district to get wards for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWards: async (districtId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'districtId' is not null or undefined
            assertParamExists('getWards', 'districtId', districtId)
            const localVarPath = `/user/location/wards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (districtId !== undefined) {
                localVarQueryParameter['districtId'] = districtId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the logged-in user\'s password
         * @summary Update User Password
         * @param {UpdateUserPasswordRequest} updateUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (updateUserPasswordRequest: UpdateUserPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserPasswordRequest' is not null or undefined
            assertParamExists('updateUserPassword', 'updateUserPasswordRequest', updateUserPasswordRequest)
            const localVarPath = `/user/info/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a specific item from the user\'s cart
         * @summary Remove item from cart
         * @param {number} cartId ID of the cart item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCartCartItemIdDelete: async (cartId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartId' is not null or undefined
            assertParamExists('userCartCartItemIdDelete', 'cartId', cartId)
            const localVarPath = `/user/cart/{cart_item_id}`
                .replace(`{${"cart_id"}}`, encodeURIComponent(String(cartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the current user\'s cart items
         * @summary Get user cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCartGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a book to the current user\'s cart
         * @summary Add book to cart
         * @param {UserCartPostRequest} userCartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCartPost: async (userCartPostRequest: UserCartPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCartPostRequest' is not null or undefined
            assertParamExists('userCartPost', 'userCartPostRequest', userCartPostRequest)
            const localVarPath = `/user/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update quantities or return dates for cart items
         * @summary Update cart items
         * @param {UserCartPutRequest} userCartPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCartPut: async (userCartPutRequest: UserCartPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCartPutRequest' is not null or undefined
            assertParamExists('userCartPut', 'userCartPutRequest', userCartPutRequest)
            const localVarPath = `/user/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCartPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the logged-in user\'s profile information
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInfoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the logged-in user\'s profile information
         * @summary Update user info
         * @param {UserInfoPutRequest} userInfoPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInfoPut: async (userInfoPutRequest: UserInfoPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInfoPutRequest' is not null or undefined
            assertParamExists('userInfoPut', 'userInfoPutRequest', userInfoPutRequest)
            const localVarPath = `/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInfoPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a book from the current user\'s wishlist
         * @summary Remove book from wishlist
         * @param {number} bookId ID of the book to remove from wishlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userWishlistBookIdDelete: async (bookId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('userWishlistBookIdDelete', 'bookId', bookId)
            const localVarPath = `/user/wishlist/{bookId}`
                .replace(`{${"bookId"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a book to the current user\'s wishlist
         * @summary Add book to wishlist
         * @param {number} bookId ID of the book to add to wishlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userWishlistBookIdPost: async (bookId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('userWishlistBookIdPost', 'bookId', bookId)
            const localVarPath = `/user/wishlist/{bookId}`
                .replace(`{${"bookId"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all books in the current user\'s wishlist
         * @summary Get user\'s wishlist
         * @param {number} [perPage] 
         * @param {number} [page] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userWishlistGet: async (perPage?: number, page?: number, searchTerm?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/wishlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['search_term'] = searchTerm;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Process the checkout for the user\'s cart
         * @summary Checkout cart
         * @param {AdminOrdersPostRequest} adminOrdersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOrdersPost(adminOrdersPostRequest: AdminOrdersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminOrdersPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOrdersPost(adminOrdersPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.adminOrdersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit a new review for a book
         * @summary Create a new review
         * @param {CreateBookReviewRequest} createBookReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBookReview(createBookReviewRequest: CreateBookReviewRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBookReview201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBookReview(createBookReviewRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.createBookReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of districts for a given province ID
         * @summary Get districts by province ID
         * @param {number} provinceId ID of the province to get districts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistricts(provinceId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDistricts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistricts(provinceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getDistricts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current user\'s order/borrowing history with optional filters (0 Borrowing, 1 Returned, 2 Overdue, 3 Lost)
         * @summary Get user\'s borrowing history
         * @param {number} [perPage] 
         * @param {string} [status] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderByUser(perPage?: number, status?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderByUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderByUser(perPage, status, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getOrderByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all provinces
         * @summary Get all provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProvinces(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProvinces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProvinces(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getProvinces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get books related to a specific book identified by slug
         * @summary Get Related Books
         * @param {string} bookSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelatedBooks(bookSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRelatedBooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelatedBooks(bookSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getRelatedBooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Books
         * @summary Get Books
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {string} [authorSlug] 
         * @param {string} [publisherSlug] 
         * @param {string} [categorySlug] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBooks(perPage?: number, searchTerm?: string, authorSlug?: string, publisherSlug?: string, categorySlug?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBooks(perPage, searchTerm, authorSlug, publisherSlug, categorySlug, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserBooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of wards for a given district ID
         * @summary Get wards by district ID
         * @param {number} districtId ID of the district to get wards for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWards(districtId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWards200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWards(districtId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getWards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the logged-in user\'s password
         * @summary Update User Password
         * @param {UpdateUserPasswordRequest} updateUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(updateUserPasswordRequest: UpdateUserPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUserPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(updateUserPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a specific item from the user\'s cart
         * @summary Remove item from cart
         * @param {number} cartId ID of the cart item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCartCartItemIdDelete(cartId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCartCartItemIdDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCartCartItemIdDelete(cartId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userCartCartItemIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the current user\'s cart items
         * @summary Get user cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCartGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCartGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCartGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userCartGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a book to the current user\'s cart
         * @summary Add book to cart
         * @param {UserCartPostRequest} userCartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCartPost(userCartPostRequest: UserCartPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCartPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCartPost(userCartPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userCartPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update quantities or return dates for cart items
         * @summary Update cart items
         * @param {UserCartPutRequest} userCartPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCartPut(userCartPutRequest: UserCartPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCartPut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCartPut(userCartPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userCartPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the logged-in user\'s profile information
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInfoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInfoGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the logged-in user\'s profile information
         * @summary Update user info
         * @param {UserInfoPutRequest} userInfoPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInfoPut(userInfoPutRequest: UserInfoPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInfoPut(userInfoPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userInfoPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a book from the current user\'s wishlist
         * @summary Remove book from wishlist
         * @param {number} bookId ID of the book to remove from wishlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userWishlistBookIdDelete(bookId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWishlistBookIdDelete204Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userWishlistBookIdDelete(bookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userWishlistBookIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a book to the current user\'s wishlist
         * @summary Add book to wishlist
         * @param {number} bookId ID of the book to add to wishlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userWishlistBookIdPost(bookId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWishlistBookIdPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userWishlistBookIdPost(bookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userWishlistBookIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all books in the current user\'s wishlist
         * @summary Get user\'s wishlist
         * @param {number} [perPage] 
         * @param {number} [page] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userWishlistGet(perPage?: number, page?: number, searchTerm?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWishlistGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userWishlistGet(perPage, page, searchTerm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userWishlistGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Process the checkout for the user\'s cart
         * @summary Checkout cart
         * @param {AdminOrdersPostRequest} adminOrdersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOrdersPost(adminOrdersPostRequest: AdminOrdersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminOrdersPost200Response> {
            return localVarFp.adminOrdersPost(adminOrdersPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a new review for a book
         * @summary Create a new review
         * @param {CreateBookReviewRequest} createBookReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookReview(createBookReviewRequest: CreateBookReviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateBookReview201Response> {
            return localVarFp.createBookReview(createBookReviewRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of districts for a given province ID
         * @summary Get districts by province ID
         * @param {number} provinceId ID of the province to get districts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistricts(provinceId: number, options?: RawAxiosRequestConfig): AxiosPromise<GetDistricts200Response> {
            return localVarFp.getDistricts(provinceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current user\'s order/borrowing history with optional filters (0 Borrowing, 1 Returned, 2 Overdue, 3 Lost)
         * @summary Get user\'s borrowing history
         * @param {number} [perPage] 
         * @param {string} [status] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderByUser(perPage?: number, status?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderByUser200Response> {
            return localVarFp.getOrderByUser(perPage, status, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all provinces
         * @summary Get all provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvinces(options?: RawAxiosRequestConfig): AxiosPromise<GetProvinces200Response> {
            return localVarFp.getProvinces(options).then((request) => request(axios, basePath));
        },
        /**
         * Get books related to a specific book identified by slug
         * @summary Get Related Books
         * @param {string} bookSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedBooks(bookSlug: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRelatedBooks200Response> {
            return localVarFp.getRelatedBooks(bookSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Books
         * @summary Get Books
         * @param {number} [perPage] 
         * @param {string} [searchTerm] 
         * @param {string} [authorSlug] 
         * @param {string} [publisherSlug] 
         * @param {string} [categorySlug] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBooks(perPage?: number, searchTerm?: string, authorSlug?: string, publisherSlug?: string, categorySlug?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBooks200Response> {
            return localVarFp.getUserBooks(perPage, searchTerm, authorSlug, publisherSlug, categorySlug, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of wards for a given district ID
         * @summary Get wards by district ID
         * @param {number} districtId ID of the district to get wards for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWards(districtId: number, options?: RawAxiosRequestConfig): AxiosPromise<GetWards200Response> {
            return localVarFp.getWards(districtId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the logged-in user\'s password
         * @summary Update User Password
         * @param {UpdateUserPasswordRequest} updateUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(updateUserPasswordRequest: UpdateUserPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateUserPassword200Response> {
            return localVarFp.updateUserPassword(updateUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a specific item from the user\'s cart
         * @summary Remove item from cart
         * @param {number} cartId ID of the cart item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCartCartItemIdDelete(cartId: number, options?: RawAxiosRequestConfig): AxiosPromise<UserCartCartItemIdDelete200Response> {
            return localVarFp.userCartCartItemIdDelete(cartId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the current user\'s cart items
         * @summary Get user cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCartGet(options?: RawAxiosRequestConfig): AxiosPromise<UserCartGet200Response> {
            return localVarFp.userCartGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Add a book to the current user\'s cart
         * @summary Add book to cart
         * @param {UserCartPostRequest} userCartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCartPost(userCartPostRequest: UserCartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserCartPost201Response> {
            return localVarFp.userCartPost(userCartPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update quantities or return dates for cart items
         * @summary Update cart items
         * @param {UserCartPutRequest} userCartPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCartPut(userCartPutRequest: UserCartPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserCartPut200Response> {
            return localVarFp.userCartPut(userCartPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the logged-in user\'s profile information
         * @summary Get user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInfoGet(options?: RawAxiosRequestConfig): AxiosPromise<UserInfoGet200Response> {
            return localVarFp.userInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the logged-in user\'s profile information
         * @summary Update user info
         * @param {UserInfoPutRequest} userInfoPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInfoPut(userInfoPutRequest: UserInfoPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserInfoGet200Response> {
            return localVarFp.userInfoPut(userInfoPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a book from the current user\'s wishlist
         * @summary Remove book from wishlist
         * @param {number} bookId ID of the book to remove from wishlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userWishlistBookIdDelete(bookId: number, options?: RawAxiosRequestConfig): AxiosPromise<UserWishlistBookIdDelete204Response> {
            return localVarFp.userWishlistBookIdDelete(bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a book to the current user\'s wishlist
         * @summary Add book to wishlist
         * @param {number} bookId ID of the book to add to wishlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userWishlistBookIdPost(bookId: number, options?: RawAxiosRequestConfig): AxiosPromise<UserWishlistBookIdPost201Response> {
            return localVarFp.userWishlistBookIdPost(bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all books in the current user\'s wishlist
         * @summary Get user\'s wishlist
         * @param {number} [perPage] 
         * @param {number} [page] 
         * @param {string} [searchTerm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userWishlistGet(perPage?: number, page?: number, searchTerm?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserWishlistGet200Response> {
            return localVarFp.userWishlistGet(perPage, page, searchTerm, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Process the checkout for the user\'s cart
     * @summary Checkout cart
     * @param {AdminOrdersPostRequest} adminOrdersPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public adminOrdersPost(adminOrdersPostRequest: AdminOrdersPostRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).adminOrdersPost(adminOrdersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a new review for a book
     * @summary Create a new review
     * @param {CreateBookReviewRequest} createBookReviewRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createBookReview(createBookReviewRequest: CreateBookReviewRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).createBookReview(createBookReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of districts for a given province ID
     * @summary Get districts by province ID
     * @param {number} provinceId ID of the province to get districts for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getDistricts(provinceId: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getDistricts(provinceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current user\'s order/borrowing history with optional filters (0 Borrowing, 1 Returned, 2 Overdue, 3 Lost)
     * @summary Get user\'s borrowing history
     * @param {number} [perPage] 
     * @param {string} [status] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getOrderByUser(perPage?: number, status?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getOrderByUser(perPage, status, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all provinces
     * @summary Get all provinces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getProvinces(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getProvinces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get books related to a specific book identified by slug
     * @summary Get Related Books
     * @param {string} bookSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getRelatedBooks(bookSlug: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getRelatedBooks(bookSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Books
     * @summary Get Books
     * @param {number} [perPage] 
     * @param {string} [searchTerm] 
     * @param {string} [authorSlug] 
     * @param {string} [publisherSlug] 
     * @param {string} [categorySlug] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserBooks(perPage?: number, searchTerm?: string, authorSlug?: string, publisherSlug?: string, categorySlug?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserBooks(perPage, searchTerm, authorSlug, publisherSlug, categorySlug, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of wards for a given district ID
     * @summary Get wards by district ID
     * @param {number} districtId ID of the district to get wards for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getWards(districtId: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getWards(districtId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the logged-in user\'s password
     * @summary Update User Password
     * @param {UpdateUserPasswordRequest} updateUserPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserPassword(updateUserPasswordRequest: UpdateUserPasswordRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserPassword(updateUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a specific item from the user\'s cart
     * @summary Remove item from cart
     * @param {number} cartId ID of the cart item to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCartCartItemIdDelete(cartId: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userCartCartItemIdDelete(cartId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the current user\'s cart items
     * @summary Get user cart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCartGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userCartGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a book to the current user\'s cart
     * @summary Add book to cart
     * @param {UserCartPostRequest} userCartPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCartPost(userCartPostRequest: UserCartPostRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userCartPost(userCartPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update quantities or return dates for cart items
     * @summary Update cart items
     * @param {UserCartPutRequest} userCartPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCartPut(userCartPutRequest: UserCartPutRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userCartPut(userCartPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the logged-in user\'s profile information
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userInfoGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the logged-in user\'s profile information
     * @summary Update user info
     * @param {UserInfoPutRequest} userInfoPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userInfoPut(userInfoPutRequest: UserInfoPutRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userInfoPut(userInfoPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a book from the current user\'s wishlist
     * @summary Remove book from wishlist
     * @param {number} bookId ID of the book to remove from wishlist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userWishlistBookIdDelete(bookId: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userWishlistBookIdDelete(bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a book to the current user\'s wishlist
     * @summary Add book to wishlist
     * @param {number} bookId ID of the book to add to wishlist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userWishlistBookIdPost(bookId: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userWishlistBookIdPost(bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all books in the current user\'s wishlist
     * @summary Get user\'s wishlist
     * @param {number} [perPage] 
     * @param {number} [page] 
     * @param {string} [searchTerm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userWishlistGet(perPage?: number, page?: number, searchTerm?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userWishlistGet(perPage, page, searchTerm, options).then((request) => request(this.axios, this.basePath));
    }
}



